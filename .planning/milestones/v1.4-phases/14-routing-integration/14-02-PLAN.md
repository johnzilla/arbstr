---
phase: 14-routing-integration
plan: 02
type: execute
wave: 2
depends_on: [14-01]
files_modified: [src/proxy/handlers.rs, tests/circuit_integration.rs]
autonomous: true
requirements: [RTG-01, RTG-02, RTG-04]

must_haves:
  truths:
    - "Streaming requests skip providers with open circuits"
    - "Streaming path returns 503 when all provider circuits are open"
    - "Streaming handler records circuit success after 2xx initial response"
    - "Integration tests verify circuit filtering and 503 fail-fast for both paths"
  artifacts:
    - path: "src/proxy/handlers.rs"
      provides: "Circuit breaker filtering and outcome recording in streaming path"
      contains: "acquire_permit"
    - path: "tests/circuit_integration.rs"
      provides: "Integration tests for circuit breaker routing behavior"
      contains: "circuit"
  key_links:
    - from: "src/proxy/handlers.rs"
      to: "src/proxy/circuit_breaker.rs"
      via: "streaming path calls acquire_permit and record_success"
      pattern: "circuit_breakers\\.(acquire_permit|record_success)"
    - from: "tests/circuit_integration.rs"
      to: "src/proxy/handlers.rs"
      via: "HTTP requests through test server verifying circuit behavior"
      pattern: "chat/completions"
---

<objective>
Wire circuit breaker filtering and outcome recording into the streaming request path, and add integration tests validating circuit behavior for both streaming and non-streaming paths.

Purpose: Streaming requests must also skip unhealthy providers, fail fast with 503 when all circuits are open, and record success after a 2xx initial response. Integration tests prove the end-to-end behavior.

Output: Modified handlers.rs streaming path with circuit integration, new test file with integration tests.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-routing-integration/14-RESEARCH.md
@.planning/phases/14-routing-integration/14-01-SUMMARY.md
@src/proxy/handlers.rs
@src/proxy/circuit_breaker.rs
@src/proxy/server.rs
@src/router/selector.rs
@tests/stats.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Streaming path circuit filtering and outcome recording</name>
  <files>src/proxy/handlers.rs</files>
  <action>
Modify the streaming path in `chat_completions` (the `if is_streaming` branch, starting around line 154). The current streaming path calls `execute_request` which internally calls `router.select()` (single provider). Replace this with candidate-based selection that goes through circuit breaker filtering, matching the non-streaming path pattern.

**Replace the streaming path** (from `if is_streaming {` to the closing brace before `} else {`):

1. **Select candidates** (same as non-streaming, using `select_candidates` instead of `select`):

```rust
if is_streaming {
    // Streaming path: select candidates and filter through circuit breaker

    // Get ordered candidate list
    let candidates = match state.router.select_candidates(
        &request.model,
        policy_name.as_deref(),
        user_prompt,
    ) {
        Ok(c) => c,
        Err(e) => {
            let latency_ms = start.elapsed().as_millis() as i64;
            let (status_code, message) = match &e {
                Error::NoProviders { .. } => (400u16, e.to_string()),
                Error::NoPolicyMatch => (400, e.to_string()),
                Error::BadRequest(_) => (400, e.to_string()),
                _ => (500, e.to_string()),
            };

            if let Some(pool) = &state.db {
                spawn_log_write(pool, RequestLog {
                    correlation_id: correlation_id.clone(),
                    timestamp: chrono::Utc::now().to_rfc3339(),
                    model: model.clone(),
                    provider: None,
                    policy: policy_name.clone(),
                    streaming: true,
                    input_tokens: None,
                    output_tokens: None,
                    cost_sats: None,
                    provider_cost_sats: None,
                    latency_ms,
                    success: false,
                    error_status: Some(status_code),
                    error_message: Some(message),
                });
            }

            let mut error_response = e.into_response();
            attach_arbstr_headers(&mut error_response, &correlation_id, latency_ms, None, None, true);
            return Ok(error_response);
        }
    };

    // Filter through circuit breaker (RTG-01)
    let mut filtered_candidates = Vec::new();
    let mut probe_provider: Option<String> = None;
    for candidate in &candidates {
        match state.circuit_breakers.acquire_permit(&candidate.name).await {
            Ok(PermitType::Normal) => {
                filtered_candidates.push(candidate.clone());
            }
            Ok(PermitType::Probe) => {
                probe_provider = Some(candidate.name.clone());
                filtered_candidates.insert(0, candidate.clone());
            }
            Err(open_err) => {
                tracing::debug!(
                    provider = %candidate.name,
                    reason = %open_err.reason,
                    "Skipping provider: circuit open (streaming)"
                );
            }
        }
    }

    // Fail-fast if all circuits open (RTG-02)
    if filtered_candidates.is_empty() {
        // ... same 503 pattern as non-streaming (copy from Plan 14-01 but with streaming: true)
    }
```

2. **Select first available provider and send request** (streaming has no retry -- just pick the first filtered candidate):

```rust
    // Streaming path uses the first (cheapest) available candidate, no retry
    let provider = &filtered_candidates[0];

    tracing::info!(
        provider = %provider.name,
        url = %provider.url,
        output_rate = %provider.output_rate,
        "Selected provider (streaming)"
    );

    let result = send_to_provider(&state, &request, provider, &correlation_id, true).await;
```

3. **Record circuit outcome** (RTG-04). Per locked decision: "if 2xx is received and streaming begins, it counts as success." The `send_to_provider` returns `Ok(RequestOutcome)` only on 2xx responses (non-2xx is Err). Record success immediately:

```rust
    // Record circuit breaker outcome (RTG-04)
    match &result {
        Ok(outcome) => {
            state.circuit_breakers.record_success(&outcome.provider_name);
            if let Some(guard) = probe_guard {
                if outcome.provider_name == probe_provider.as_deref().unwrap_or("") {
                    guard.success();
                } else {
                    guard.failure("not_reached", "different provider succeeded");
                }
            }
        }
        Err(outcome_err) => {
            if is_circuit_failure(outcome_err.status_code) {
                state.circuit_breakers.record_failure(
                    outcome_err.provider_name.as_deref().unwrap_or("unknown"),
                    "5xx",
                    &format!("HTTP {}", outcome_err.status_code),
                );
            }
            if let Some(guard) = probe_guard {
                if is_circuit_failure(outcome_err.status_code) {
                    guard.failure("5xx", &format!("HTTP {}", outcome_err.status_code));
                } else {
                    // Non-5xx error (e.g., 4xx) -- don't trip circuit, but probe didn't succeed
                    guard.failure("non_5xx", &format!("HTTP {}", outcome_err.status_code));
                }
            }
        }
    }
```

Create the ProbeGuard BEFORE send_to_provider (similar to non-streaming):
```rust
    let probe_guard: Option<ProbeGuard<'_>> = probe_provider.as_ref().map(|name| {
        ProbeGuard::new(&state.circuit_breakers, name.clone())
    });
```

4. **Keep existing logging and response building** -- the existing DB logging and header attachment code after the result can stay largely unchanged, but now uses the `result` from the direct `send_to_provider` call instead of `execute_request`.

5. **Remove or deprecate `execute_request` function** -- After this change, the streaming path no longer calls `execute_request`. Check if any other code path still calls it. If not, remove it. If it's only used by streaming and is now replaced, remove the function to avoid dead code warnings.

After all changes, run `cargo fmt`, `cargo clippy -- -D warnings`, and `cargo test`.
  </action>
  <verify>
Run `cargo build` to verify compilation. Run `cargo clippy -- -D warnings` for lint compliance. Run `cargo test` to verify all existing tests pass. Verify that `execute_request` is either still used or removed (no dead code warnings).
  </verify>
  <done>
Streaming path filters candidates through circuit breaker. All circuits open returns 503. Circuit success recorded after 2xx initial response. ProbeGuard resolved on success and failure paths. No dead code warnings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for circuit breaker routing</name>
  <files>tests/circuit_integration.rs</files>
  <action>
Create integration tests that verify circuit breaker routing behavior end-to-end. Follow the existing test patterns from `tests/stats.rs` and `tests/logs.rs` (setup_test_app pattern with tower::oneshot).

**Test helpers needed:**

Use the same `setup_test_app` pattern from existing integration tests but with mock providers configured. Since the tests use `tower::ServiceExt::oneshot` (no actual HTTP server), we need to set up AppState with providers that the handler can call. However, the circuit breaker tests don't need actual provider responses -- they test the ROUTING decision (which providers are selected/skipped).

For these tests, configure AppState with providers but trip their circuits manually using `registry.record_failure()` before making requests. The actual `send_to_provider` calls will fail (no real server), but we can verify:

1. **503 response when all circuits open** -- trip all provider circuits, send request, verify 503
2. **Skips open circuit, routes to next** -- trip provider A's circuit, verify request routes to provider B (by checking response headers or error mentioning provider B)
3. **Success records circuit success** -- send request through mock, verify circuit state after

Since we need controlled provider responses, use a lightweight mock HTTP server approach:

```rust
use axum::{routing::post, Router as AxumRouter, Json};

async fn mock_provider_handler() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "id": "chatcmpl-test",
        "object": "chat.completion",
        "choices": [{"message": {"role": "assistant", "content": "test"}, "index": 0, "finish_reason": "stop"}],
        "usage": {"prompt_tokens": 10, "completion_tokens": 5, "total_tokens": 15}
    }))
}
```

Bind this to a random port using `TcpListener::bind("127.0.0.1:0")` and use the assigned address in provider URLs.

**Test cases (minimum 5):**

1. `test_non_streaming_503_all_circuits_open` -- Configure 2 providers for model "gpt-4o". Trip both circuits (3 failures each). Send POST /v1/chat/completions with `stream: false`. Assert: HTTP 503, body contains "open circuits", `x-arbstr-request-id` header present.

2. `test_non_streaming_skips_open_circuit` -- Configure 2 providers: provider-a (cheaper) and provider-b. Trip provider-a's circuit. Send non-streaming request. Assert: request succeeds (200) via provider-b, `x-arbstr-provider` header is "provider-b".

3. `test_streaming_503_all_circuits_open` -- Same as test 1 but with `stream: true`. Assert: HTTP 503.

4. `test_streaming_skips_open_circuit` -- Same as test 2 but with `stream: true`. Assert: request succeeds via provider-b.

5. `test_circuit_records_failure_on_5xx` -- Configure 1 provider pointed at a mock that returns 500. Send request. Verify circuit failure count incremented (check via `registry.failure_count()`).

6. `test_circuit_stays_closed_on_4xx` -- Configure 1 provider pointed at a mock that returns 400. Send request. Verify circuit failure count is still 0.

7. `test_non_streaming_records_success` -- Configure 1 provider pointed at a working mock. Send non-streaming request. Verify circuit state is still Closed and failure count is 0.

**Test setup pattern:**

```rust
use std::sync::Arc;
use arbstr::proxy::{CircuitBreakerRegistry, CircuitState};

fn setup_circuit_test_app(
    providers: Vec<arbstr::config::ProviderConfig>,
) -> (axum::Router, Arc<CircuitBreakerRegistry>) {
    let provider_names: Vec<String> = providers.iter().map(|p| p.name.clone()).collect();
    let registry = Arc::new(CircuitBreakerRegistry::new(&provider_names));

    let router = arbstr::router::Router::new(providers, vec![], "cheapest".to_string());
    let state = arbstr::proxy::server::AppState {
        router: Arc::new(router),
        http_client: reqwest::Client::new(),
        config: Arc::new(/* minimal config */),
        db: None,
        read_db: None,
        circuit_breakers: registry.clone(),
    };
    let app = arbstr::proxy::server::create_router(state);
    (app, registry)
}
```

Use `tower::ServiceExt::oneshot` to send requests through the app without binding a port. For tests that need a real provider response, spin up a minimal axum server on a random port as the mock provider.

For tripping circuits, use `registry.record_failure(name, "5xx", "test")` called 3 times (FAILURE_THRESHOLD).

Follow the existing test file conventions: `use tower::ServiceExt;`, `use http::{Request, StatusCode};`, parse response body as `serde_json::Value`.
  </action>
  <verify>
Run `cargo test --test circuit_integration` to verify all new tests pass. Run `cargo test` to verify no regressions. Run `cargo clippy -- -D warnings` for lint compliance.
  </verify>
  <done>
At least 5 integration tests exist and pass, covering: 503 fail-fast (both paths), open circuit skip (both paths), failure recording on 5xx, no failure on 4xx, success recording. All existing tests still pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --release` compiles without errors
2. `cargo clippy -- -D warnings` passes clean
3. `cargo test` passes all tests (existing + new)
4. Streaming path calls `acquire_permit` before selecting provider
5. Streaming 503 returned when all circuits open
6. Streaming success records `record_success` immediately after 2xx
7. `execute_request` removed or still used (no dead code)
8. Integration tests cover 503, skip-open, outcome recording
9. At least 5 new integration tests pass
</verification>

<success_criteria>
- Streaming requests skip providers with open circuits
- Streaming returns 503 when all circuits open
- Streaming records circuit success after 2xx initial response
- Integration tests prove circuit behavior end-to-end
- All 166+ existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-routing-integration/14-02-SUMMARY.md`
</output>
