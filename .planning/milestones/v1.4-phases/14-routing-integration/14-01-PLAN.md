---
phase: 14-routing-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/error.rs, src/proxy/handlers.rs]
autonomous: true
requirements: [RTG-01, RTG-02, RTG-03]

must_haves:
  truths:
    - "Non-streaming requests skip providers with open circuits and route to next cheapest"
    - "When all providers have open circuits, the proxy returns 503 without attempting any requests"
    - "After non-streaming retry completes, circuit breaker records outcome for each attempted provider"
    - "ProbeGuard is created before timeout_at and resolved on all exit paths"
  artifacts:
    - path: "src/error.rs"
      provides: "CircuitOpen error variant mapping to 503"
      contains: "CircuitOpen"
    - path: "src/proxy/handlers.rs"
      provides: "Circuit breaker filtering and outcome recording in non-streaming path"
      contains: "acquire_permit"
  key_links:
    - from: "src/proxy/handlers.rs"
      to: "src/proxy/circuit_breaker.rs"
      via: "state.circuit_breakers.acquire_permit / record_success / record_failure"
      pattern: "circuit_breakers\\.(acquire_permit|record_success|record_failure)"
    - from: "src/proxy/handlers.rs"
      to: "src/proxy/circuit_breaker.rs"
      via: "ProbeGuard RAII lifecycle"
      pattern: "ProbeGuard::new"
    - from: "src/error.rs"
      to: "handlers.rs"
      via: "Error::CircuitOpen returned when all circuits open"
      pattern: "CircuitOpen"
---

<objective>
Wire circuit breaker filtering and outcome recording into the non-streaming request path. Add the Error::CircuitOpen variant for 503 fail-fast responses.

Purpose: Non-streaming requests must skip unhealthy providers (open circuits), fail fast with 503 when no alternatives exist, and record success/failure outcomes to the circuit breaker after each request attempt.

Output: Modified error.rs with CircuitOpen variant, modified handlers.rs with pre-retry circuit filtering and post-retry outcome recording.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-routing-integration/14-RESEARCH.md
@.planning/phases/13-circuit-breaker-state-machine/13-02-SUMMARY.md
@src/error.rs
@src/proxy/handlers.rs
@src/proxy/circuit_breaker.rs
@src/proxy/retry.rs
@src/proxy/server.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Error::CircuitOpen variant and circuit helper functions</name>
  <files>src/error.rs, src/proxy/handlers.rs</files>
  <action>
1. In `src/error.rs`, add a new variant to the Error enum:

```rust
#[error("All providers have open circuits for model '{model}'")]
CircuitOpen { model: String },
```

2. In the `IntoResponse` implementation for Error, add the match arm:

```rust
Error::CircuitOpen { .. } => (StatusCode::SERVICE_UNAVAILABLE, self.to_string()),
```

This maps CircuitOpen to HTTP 503 Service Unavailable with the OpenAI-compatible error JSON format that already exists.

3. In `src/proxy/handlers.rs`, add two helper functions at module level (near the top, after the existing helper functions):

```rust
/// Whether an HTTP status code should be recorded as a circuit breaker failure.
///
/// Returns true for 5xx server errors (aligned with retry::is_retryable).
/// Returns false for 4xx client errors and all other codes.
fn is_circuit_failure(status_code: u16) -> bool {
    (500..600).contains(&status_code)
}
```

4. Add the necessary imports to handlers.rs:

```rust
use super::circuit_breaker::{PermitType, ProbeGuard};
```

Do NOT import CircuitOpenError -- it is only used indirectly via acquire_permit's Err return.
  </action>
  <verify>
Run `cargo build` to verify compilation. Run `cargo clippy -- -D warnings` to check for warnings. Run `cargo test` to verify no regressions.
  </verify>
  <done>
Error::CircuitOpen variant exists and maps to 503 in IntoResponse. is_circuit_failure helper exists in handlers.rs. PermitType and ProbeGuard are imported. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Non-streaming circuit filtering and outcome recording</name>
  <files>src/proxy/handlers.rs</files>
  <action>
Modify the non-streaming path in `chat_completions` (the `else` branch starting around line 234). The changes are in three locations:

**Location 1: Pre-retry circuit filtering (after `select_candidates`, before building `candidate_infos`)**

After the `candidates` variable is assigned from `select_candidates()` (around line 238-287), and BEFORE the `candidate_infos` construction (around line 290), insert circuit breaker filtering:

```rust
// Filter candidates through circuit breaker (RTG-01)
let mut filtered_candidates = Vec::new();
let mut probe_provider: Option<String> = None;
for candidate in &candidates {
    match state.circuit_breakers.acquire_permit(&candidate.name).await {
        Ok(PermitType::Normal) => {
            filtered_candidates.push(candidate.clone());
        }
        Ok(PermitType::Probe) => {
            probe_provider = Some(candidate.name.clone());
            // Probe candidate goes first -- it IS the probe request
            filtered_candidates.insert(0, candidate.clone());
        }
        Err(open_err) => {
            tracing::debug!(
                provider = %candidate.name,
                reason = %open_err.reason,
                "Skipping provider: circuit open"
            );
        }
    }
}

// Fail-fast if all circuits are open (RTG-02)
if filtered_candidates.is_empty() {
    let latency_ms = start.elapsed().as_millis() as i64;

    // Log the circuit-open error
    if let Some(pool) = &state.db {
        spawn_log_write(
            pool,
            RequestLog {
                correlation_id: correlation_id.clone(),
                timestamp: chrono::Utc::now().to_rfc3339(),
                model: model.clone(),
                provider: None,
                policy: policy_name.clone(),
                streaming: false,
                input_tokens: None,
                output_tokens: None,
                cost_sats: None,
                provider_cost_sats: None,
                latency_ms,
                success: false,
                error_status: Some(503),
                error_message: Some(format!("All providers have open circuits for model '{}'", model)),
            },
        );
    }

    let circuit_error = Error::CircuitOpen { model: model.clone() };
    let mut error_response = circuit_error.into_response();
    attach_arbstr_headers(
        &mut error_response,
        &correlation_id,
        latency_ms,
        None,
        None,
        false,
    );
    return Ok(error_response);
}
```

Then change the `candidate_infos` construction to use `filtered_candidates` instead of `candidates`:

```rust
let candidate_infos: Vec<CandidateInfo> = filtered_candidates
    .iter()
    .map(|c| CandidateInfo {
        name: c.name.clone(),
    })
    .collect();
```

**CRITICAL: Create ProbeGuard BEFORE timeout_at** so it outlives the timeout future. If timeout fires, ProbeGuard's Drop will correctly record failure.

```rust
// Create ProbeGuard before timeout_at so it survives cancellation
let probe_guard: Option<ProbeGuard<'_>> = probe_provider.as_ref().map(|name| {
    ProbeGuard::new(&state.circuit_breakers, name.clone())
});
```

Place this AFTER the `filtered_candidates` construction but BEFORE the `timeout_at` call.

Also update the `send_to_provider` closure inside `retry_with_fallback` to use `filtered_candidates` instead of `candidates`:

```rust
let provider = filtered_candidates
    .iter()
    .find(|c| c.name == info.name)
    .expect("candidate info must match a provider");
```

**Location 2: Post-retry outcome recording (after `timeout_result` is resolved)**

After `let latency_ms = start.elapsed().as_millis() as i64;` and BEFORE the `match timeout_result` block, add circuit breaker outcome recording:

```rust
// Record circuit breaker outcomes (RTG-03)
// Record failures for all failed attempts with 5xx status codes
let recorded_attempts = attempts.lock().unwrap().clone();
for attempt in &recorded_attempts {
    if is_circuit_failure(attempt.status_code) {
        state.circuit_breakers.record_failure(
            &attempt.provider_name,
            "5xx",
            &format!("HTTP {}", attempt.status_code),
        );
    }
}
```

Note: The `recorded_attempts` variable is already created on the NEXT line in the existing code. Move the existing `let recorded_attempts = attempts.lock().unwrap().clone();` UP to this location so it's computed once, and used for both circuit recording and the retries header.

**Location 3: Resolve ProbeGuard in each match arm**

In the `match timeout_result` block, resolve the probe_guard in each branch:

- **Timeout branch (`Err(_elapsed)`):** Add before the existing timeout handling:
```rust
// Timeout: ProbeGuard's Drop will record failure (no explicit resolution needed)
// But we can be explicit:
if let Some(guard) = probe_guard {
    guard.failure("timeout", "retry chain timed out");
}
```

Wait -- the `probe_guard` must be consumed or dropped. Since `timeout_result` is already computed at this point, the probe_guard is still alive. Drop it explicitly in each branch.

Actually, the simplest approach: after circuit outcome recording but before the `match timeout_result`, resolve the ProbeGuard based on whether any attempt with the probe provider's name succeeded:

```rust
// Resolve ProbeGuard based on retry outcome (RTG-03)
if let Some(guard) = probe_guard {
    let probe_name = probe_provider.as_deref().unwrap_or("");
    match &timeout_result {
        Ok(retry_outcome) => match &retry_outcome.result {
            Ok(outcome) if outcome.provider_name == probe_name => {
                // Record success for winning provider
                state.circuit_breakers.record_success(&outcome.provider_name);
                guard.success();
            }
            Ok(outcome) => {
                // Different provider succeeded -- probe provider didn't get to run or failed
                state.circuit_breakers.record_success(&outcome.provider_name);
                guard.failure("not_reached", "probe provider was not the winning provider");
            }
            Err(_) => {
                guard.failure("5xx", "all providers failed");
            }
        },
        Err(_timeout) => {
            guard.failure("timeout", "retry chain timed out");
        }
    }
} else {
    // No probe -- just record success for winning provider
    match &timeout_result {
        Ok(retry_outcome) => {
            if let Ok(outcome) = &retry_outcome.result {
                state.circuit_breakers.record_success(&outcome.provider_name);
            }
        }
        Err(_) => {} // Timeout with no probe -- nothing to record
    }
}
```

**Important detail:** The `retry_outcome.result` is behind a reference in the match, so use `&timeout_result` to avoid moving. The existing code below uses `timeout_result` by move in its own match, so the circuit recording must happen first (using references), then the existing match can proceed by move.

WAIT: This won't work because `timeout_result` is consumed by move in the existing `match timeout_result` block. The solution: change the existing `match timeout_result` to `match &timeout_result` for the circuit recording, then use a second `match timeout_result` by move for the response building. OR, integrate the circuit recording INTO the existing match arms.

**Revised approach -- integrate into existing match arms:**

In the `Err(_elapsed)` (timeout) arm, add at the top:
```rust
// Record circuit failure for timeout
if let Some(guard) = probe_guard {
    guard.failure("timeout", "retry chain timed out");
}
```

In the `Ok(retry_outcome) => match retry_outcome.result` -> `Ok(outcome)` (success) arm, add at the top:
```rust
// Record circuit success
state.circuit_breakers.record_success(&outcome.provider_name);
if let Some(guard) = probe_guard {
    let probe_name = probe_provider.as_deref().unwrap_or("");
    if outcome.provider_name == probe_name {
        guard.success();
    } else {
        guard.failure("not_reached", "different provider succeeded");
    }
}
```

In the `Ok(retry_outcome) => match retry_outcome.result` -> `Err(outcome_err)` (all failed) arm, add at the top:
```rust
// Record circuit failure
if let Some(guard) = probe_guard {
    guard.failure("5xx", "all providers failed");
}
```

**CRITICAL lifetime issue:** `ProbeGuard<'a>` borrows `&'a CircuitBreakerRegistry`. `state.circuit_breakers` is `Arc<CircuitBreakerRegistry>`. `state` is owned by the handler (Clone). The ProbeGuard borrows from the deref of the Arc. The handler function scope owns `state`, so the deref is valid for the handler's lifetime. The ProbeGuard created from `&state.circuit_breakers` (via `ProbeGuard::new(&state.circuit_breakers, ...)`) borrows `&CircuitBreakerRegistry` which lives as long as `state`. This should work because `state` outlives `probe_guard`.

After all changes, run `cargo clippy -- -D warnings` and `cargo test`.
  </action>
  <verify>
Run `cargo build` to verify compilation. Run `cargo clippy -- -D warnings` for lint compliance. Run `cargo test` to verify all existing tests pass (166 tests). Specifically verify the handler compiles with ProbeGuard lifetime across the timeout_at boundary.
  </verify>
  <done>
Non-streaming path filters candidates through circuit breaker before retry loop. Empty candidates returns 503. Per-attempt 5xx failures are recorded to circuit breaker. Success is recorded for the winning provider. ProbeGuard is created before timeout_at and resolved on all three exit paths (success, failure, timeout). All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build --release` compiles without errors
2. `cargo clippy -- -D warnings` passes clean
3. `cargo test` passes all existing tests (166+)
4. Error::CircuitOpen maps to 503 Service Unavailable
5. is_circuit_failure returns true only for 500-599
6. ProbeGuard created outside timeout_at scope
7. acquire_permit called for each candidate in non-streaming path
8. record_failure called for each 5xx attempt record
9. record_success called for winning provider on success
10. ProbeGuard resolved (success/failure) on all exit paths
</verification>

<success_criteria>
- Non-streaming requests skip providers with open circuits
- All circuits open returns 503 without provider requests
- Circuit breaker records per-attempt outcomes after retry
- ProbeGuard survives timeout cancellation
- All 166+ existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-routing-integration/14-01-SUMMARY.md`
</output>
