---
phase: 13-circuit-breaker-state-machine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/proxy/circuit_breaker.rs
autonomous: true
requirements:
  - CB-01
  - CB-02
  - CB-03
  - CB-04
  - CB-06

must_haves:
  truths:
    - "CircuitBreakerInner starts in Closed state with zero failure count"
    - "Three consecutive failures transition state from Closed to Open"
    - "A success between failures resets the counter so non-consecutive failures never trip"
    - "4xx responses do not increment the failure counter"
    - "After 30 seconds in Open state, check_state returns ProbePermit (lazy Half-Open transition)"
    - "Probe success transitions Half-Open to Closed with counter reset"
    - "Probe failure transitions Half-Open to Open with fresh 30s timer"
    - "State transitions log at correct levels (WARN for open, INFO for close/half-open)"
    - "Trip count increments each time circuit opens"
    - "Last error, opened_at, last_failure_time, and last_success_time are tracked"
  artifacts:
    - path: "src/proxy/circuit_breaker.rs"
      provides: "Circuit breaker state machine types and transition logic"
      contains: "CircuitState"
      min_lines: 200
    - path: "Cargo.toml"
      provides: "dashmap dependency"
      contains: "dashmap"
  key_links:
    - from: "src/proxy/circuit_breaker.rs"
      to: "tokio::time::Instant"
      via: "opened_at field for lazy Open->HalfOpen transition"
      pattern: "tokio::time::Instant"
---

<objective>
Build the core circuit breaker state machine with full test coverage using TDD.

Purpose: Create the independently testable state machine that tracks consecutive failures and implements the Closed -> Open -> Half-Open -> Closed lifecycle. This is the foundation that Plan 13-02 wraps with concurrency primitives (DashMap registry, watch channel, ProbeGuard).

Output: `src/proxy/circuit_breaker.rs` with CircuitState enum, CircuitBreakerInner struct, all state transition methods, and comprehensive unit tests. Also adds `dashmap = "6"` to Cargo.toml (needed by Plan 13-02 but added now to avoid file conflict).
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-circuit-breaker-state-machine/13-RESEARCH.md
@src/proxy/retry.rs
@src/error.rs
@Cargo.toml
</context>

<feature>
  <name>Circuit Breaker State Machine</name>
  <files>src/proxy/circuit_breaker.rs, Cargo.toml</files>
  <behavior>
    The circuit breaker state machine manages per-provider health with three states:

    **Types to create:**

    ```rust
    // Constants (hardcoded per decision)
    const FAILURE_THRESHOLD: u32 = 3;
    const OPEN_DURATION: Duration = Duration::from_secs(30);

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum CircuitState { Closed, Open, HalfOpen }

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum ProbeResult { Pending, Success, Failed }

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum CheckResult { Allowed, ProbePermit, WaitForProbe, Rejected }

    #[derive(Debug, Clone)]
    pub struct LastError { pub error_type: String, pub message: String }

    #[derive(Debug, Clone)]
    pub struct CircuitOpenError {
        pub provider: String,
        pub reason: String,
        pub trip_count: u32,
    }
    // Implement Display and std::error::Error for CircuitOpenError

    pub(crate) struct CircuitBreakerInner {
        pub(crate) state: CircuitState,
        pub(crate) failure_count: u32,
        pub(crate) opened_at: Option<tokio::time::Instant>,
        pub(crate) last_failure_time: Option<tokio::time::Instant>,
        pub(crate) last_success_time: Option<tokio::time::Instant>,
        pub(crate) last_error: Option<LastError>,
        pub(crate) trip_count: u32,
        pub(crate) probe_in_flight: bool,
    }
    ```

    **State transition methods on CircuitBreakerInner:**

    - `new() -> Self` -- Starts Closed, zero counters, no timestamps
    - `check_state(&mut self) -> CheckResult` -- Lazy evaluation:
      - Closed -> Allowed
      - Open + timeout expired -> transition to HalfOpen, log INFO, then try_acquire_probe()
      - Open + timeout not expired -> Rejected
      - HalfOpen -> try_acquire_probe()
    - `try_acquire_probe(&mut self) -> CheckResult` -- private helper:
      - probe_in_flight == false -> set true, return ProbePermit
      - probe_in_flight == true -> return WaitForProbe
    - `record_failure(&mut self, provider_name: &str, error_type: &str, message: &str)`:
      - Only call in Closed state (Open rejects, HalfOpen uses probe methods)
      - Increment failure_count, set last_failure_time, set last_error
      - If failure_count >= FAILURE_THRESHOLD: transition to Open, set opened_at, increment trip_count, log WARN
    - `record_success(&mut self, provider_name: &str)`:
      - In Closed state: reset failure_count to 0, set last_success_time
    - `record_probe_success(&mut self, provider_name: &str)`:
      - Transition HalfOpen -> Closed, reset failure_count to 0, set probe_in_flight false, set last_success_time, log INFO
    - `record_probe_failure(&mut self, provider_name: &str, error_type: &str, message: &str)`:
      - Transition HalfOpen -> Open, set fresh opened_at, set probe_in_flight false, set last_error, log WARN

    **Test cases (TDD -- write tests FIRST, then implement):**

    All tests use `#[tokio::test(start_paused = true)]` for deterministic time.

    1. `test_initial_state` -- new() returns Closed, failure_count=0, trip_count=0
    2. `test_single_failure_stays_closed` -- 1 failure -> still Closed, failure_count=1
    3. `test_two_failures_stays_closed` -- 2 failures -> still Closed, failure_count=2
    4. `test_three_failures_opens_circuit` -- 3 failures -> Open, trip_count=1
    5. `test_success_resets_failure_count` -- 2 failures, 1 success, 2 failures -> still Closed (non-consecutive)
    6. `test_open_rejects_requests` -- Open circuit -> check_state returns Rejected
    7. `test_open_transitions_to_half_open_after_timeout` -- Open, advance 31s -> check_state returns ProbePermit, state is HalfOpen
    8. `test_open_stays_open_before_timeout` -- Open, advance 29s -> check_state returns Rejected
    9. `test_half_open_single_probe_permit` -- HalfOpen, first check -> ProbePermit, second check -> WaitForProbe
    10. `test_probe_success_closes_circuit` -- HalfOpen, record_probe_success -> Closed, failure_count=0
    11. `test_probe_failure_reopens_circuit` -- HalfOpen, record_probe_failure -> Open with fresh opened_at
    12. `test_probe_failure_resets_timer` -- record_probe_failure, advance 31s -> should transition to HalfOpen (fresh timer)
    13. `test_trip_count_increments` -- trip Open, recover, trip again -> trip_count=2
    14. `test_last_error_tracked` -- record failures with different messages, last_error reflects most recent
    15. `test_timestamps_tracked` -- verify opened_at, last_failure_time, last_success_time set correctly
    16. `test_check_result_values` -- verify all four CheckResult variants produce correct values
  </behavior>
  <implementation>
    After all tests are written and failing (RED):

    1. Add `dashmap = "6"` to `[dependencies]` in Cargo.toml (Plan 13-02 needs it; adding here avoids file ownership conflict)
    2. Create `src/proxy/circuit_breaker.rs` with all types (CircuitState, CircuitBreakerInner, CheckResult, ProbeResult, LastError, CircuitOpenError, constants)
    3. Implement CircuitBreakerInner::new()
    4. Implement check_state() with lazy Open->HalfOpen transition using tokio::time::Instant::now()
    5. Implement try_acquire_probe() for single-permit model
    6. Implement record_failure() with FAILURE_THRESHOLD check and WARN logging on open
    7. Implement record_success() with counter reset and INFO logging
    8. Implement record_probe_success() with HalfOpen->Closed transition and INFO logging
    9. Implement record_probe_failure() with HalfOpen->Open transition, fresh opened_at, and WARN logging
    10. Run tests -- all GREEN
    11. Refactor if needed (extract common transition helpers)

    **Transition logging (per locked decision):**
    - WARN level when circuit opens: `tracing::warn!(provider = %provider_name, failure_count, last_error = ?self.last_error, trip_count, "circuit OPENED: {} consecutive failures", self.failure_count)`
    - INFO level when circuit enters half-open: `tracing::info!(provider = %provider_name, "circuit entering Half-Open: timeout expired")`
    - INFO level when circuit closes: `tracing::info!(provider = %provider_name, trip_count, "circuit CLOSED: probe succeeded")`
    - WARN level when probe fails (reopening): `tracing::warn!(provider = %provider_name, trip_count, "circuit REOPENED: probe failed")`

    **Important:** Do NOT declare the module in proxy/mod.rs yet -- Plan 13-02 handles module wiring. The tests in this plan are `#[cfg(test)] mod tests` inside circuit_breaker.rs itself, which compile independently. Run tests with `cargo test --lib circuit_breaker` or `cargo test circuit_breaker`.

    Note: The file will NOT compile as part of the library until Plan 13-02 adds `mod circuit_breaker;` to proxy/mod.rs. That is expected. Tests within the file itself will work via `cargo test --lib` targeting the specific test module, but the canonical approach is: write the file, add the module declaration in proxy/mod.rs at the end of this plan (just `pub mod circuit_breaker;` with no re-exports yet), and verify `cargo test` passes. This keeps the build green between plans.

    Actually, to keep the build green: at the END of this plan, add `pub mod circuit_breaker;` to `src/proxy/mod.rs` so the module compiles as part of the crate. Do NOT add re-exports yet (Plan 13-02 handles that). This means `src/proxy/mod.rs` is a file touched by this plan.
  </implementation>
</feature>

<verification>
```bash
# All circuit breaker unit tests pass
cargo test circuit_breaker -- --nocapture

# Full test suite still passes (no regressions)
cargo test

# Clippy clean
cargo clippy -- -D warnings

# dashmap dependency resolves
cargo check
```
</verification>

<success_criteria>
- CircuitBreakerInner state machine has all 3 states and transitions correctly between them
- 16+ unit tests pass covering all transition paths (RED then GREEN)
- Consecutive failure tracking works: 3 failures trip, success resets counter
- Lazy Open->HalfOpen transition fires after 30s (verified with tokio time advance)
- Single-permit half-open: first caller gets ProbePermit, second gets WaitForProbe
- Probe success closes circuit; probe failure reopens with fresh timer
- Trip count, timestamps, and last error tracked correctly
- Tracing logs emitted at correct levels for state transitions
- dashmap dependency added to Cargo.toml
- `cargo test` and `cargo clippy -- -D warnings` pass cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/13-circuit-breaker-state-machine/13-01-SUMMARY.md`
</output>
