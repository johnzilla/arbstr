---
phase: 13-circuit-breaker-state-machine
plan: 02
type: execute
wave: 2
depends_on:
  - "13-01"
files_modified:
  - src/proxy/circuit_breaker.rs
  - src/proxy/mod.rs
  - src/proxy/server.rs
autonomous: true
requirements:
  - CB-01
  - CB-04
  - CB-05
  - CB-06

must_haves:
  truths:
    - "CircuitBreakerRegistry holds per-provider circuit breakers in a DashMap"
    - "acquire_permit returns Ok for closed circuits and blocks during half-open probe"
    - "acquire_permit returns CircuitOpenError for open circuits"
    - "Queue-and-wait: multiple requests waiting for a probe all receive the correct result"
    - "ProbeGuard RAII calls record_probe_failure on drop if not explicitly resolved"
    - "Registry is initialized in AppState with one breaker per configured provider"
    - "record_success and record_failure on registry delegate to inner state machine"
  artifacts:
    - path: "src/proxy/circuit_breaker.rs"
      provides: "CircuitBreakerRegistry, ProviderCircuitBreaker, ProbeGuard, acquire_permit"
      contains: "CircuitBreakerRegistry"
      min_lines: 350
    - path: "src/proxy/mod.rs"
      provides: "Re-exports for circuit breaker public types"
      contains: "circuit_breaker"
    - path: "src/proxy/server.rs"
      provides: "CircuitBreakerRegistry in AppState"
      contains: "CircuitBreakerRegistry"
  key_links:
    - from: "src/proxy/circuit_breaker.rs"
      to: "dashmap::DashMap"
      via: "breakers field on CircuitBreakerRegistry"
      pattern: "DashMap<String, ProviderCircuitBreaker>"
    - from: "src/proxy/circuit_breaker.rs"
      to: "tokio::sync::watch"
      via: "probe_watch field for probe result broadcasting"
      pattern: "watch::Sender<ProbeResult>"
    - from: "src/proxy/server.rs"
      to: "src/proxy/circuit_breaker.rs"
      via: "AppState.circuit_breakers field"
      pattern: "CircuitBreakerRegistry"
---

<objective>
Build the concurrent registry layer, queue-and-wait probe signaling, and ProbeGuard RAII on top of the core state machine. Wire registry into AppState.

Purpose: Wrap the pure state machine (from Plan 13-01) with DashMap-based per-provider access, tokio::sync::watch-based probe result broadcasting for queue-and-wait semantics, and a ProbeGuard that prevents stuck probe_in_flight flags. Also initializes the registry in AppState so Phase 14 can consume it.

Output: Extended `src/proxy/circuit_breaker.rs` with registry and concurrency primitives, updated `src/proxy/mod.rs` with re-exports, updated `src/proxy/server.rs` with CircuitBreakerRegistry in AppState.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-circuit-breaker-state-machine/13-RESEARCH.md
@.planning/phases/13-circuit-breaker-state-machine/13-01-SUMMARY.md
@src/proxy/circuit_breaker.rs
@src/proxy/mod.rs
@src/proxy/server.rs
@src/proxy/handlers.rs
@src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Registry, ProviderCircuitBreaker, and acquire_permit with queue-and-wait</name>
  <files>src/proxy/circuit_breaker.rs</files>
  <action>
    Add the following types and methods to circuit_breaker.rs (after the existing CircuitBreakerInner code from Plan 13-01):

    **ProviderCircuitBreaker struct:**
    ```rust
    pub(crate) struct ProviderCircuitBreaker {
        inner: std::sync::Mutex<CircuitBreakerInner>,
        probe_watch: tokio::sync::watch::Sender<ProbeResult>,
    }
    ```
    - Constructor takes provider_name (for registry initialization)
    - The watch channel is initialized with `ProbeResult::Pending`

    **CircuitBreakerRegistry struct:**
    ```rust
    pub struct CircuitBreakerRegistry {
        breakers: DashMap<String, ProviderCircuitBreaker>,
    }
    ```

    Methods on CircuitBreakerRegistry:
    - `new(provider_names: &[String]) -> Self` -- Creates a DashMap with one ProviderCircuitBreaker per provider name, all starting in Closed state
    - `acquire_permit(&self, provider_name: &str) -> Result<PermitType, CircuitOpenError>` -- async method:
      1. Get DashMap entry for provider_name. If provider unknown, return Ok (circuit breaker is opt-in for known providers).
      2. Lock inner Mutex, call check_state(), extract result. Drop Mutex guard. Drop DashMap entry ref.
      3. Match on CheckResult:
         - Allowed -> Ok(PermitType::Normal)
         - ProbePermit -> Ok(PermitType::Probe) (caller must use ProbeGuard)
         - Rejected -> Err(CircuitOpenError { provider, reason from last_error, trip_count })
         - WaitForProbe -> Clone watch::Receiver (via probe_watch.subscribe()), drop all locks, then loop: rx.changed().await, check *rx.borrow() -- if Success return Ok(PermitType::Normal), if Failed return Err(CircuitOpenError), if Pending continue waiting
      4. CRITICAL: No Mutex or DashMap entry held across any .await point
    - `record_success(&self, provider_name: &str)` -- Lock inner, call inner.record_success(provider_name). If state was HalfOpen, this is a probe success: also send ProbeResult::Success on watch channel, and reset watch to Pending for next cycle.
    - `record_failure(&self, provider_name: &str, error_type: &str, message: &str)` -- Lock inner, call inner.record_failure(provider_name, error_type, message). No watch channel interaction (failures in Closed state don't affect probe waiters).
    - `record_probe_success(&self, provider_name: &str)` -- Lock inner, call inner.record_probe_success(provider_name), send ProbeResult::Success on watch channel. Then immediately send ProbeResult::Pending to reset for next cycle (prevents stale value pitfall from RESEARCH.md Pitfall 2).
    - `record_probe_failure(&self, provider_name: &str, error_type: &str, message: &str)` -- Lock inner, call inner.record_probe_failure(provider_name, error_type, message), send ProbeResult::Failed on watch channel. Then immediately send ProbeResult::Pending to reset for next cycle.
    - `state(&self, provider_name: &str) -> Option<CircuitState>` -- Read-only accessor for Phase 15 health endpoint. Lock inner, read state, return.
    - `failure_count(&self, provider_name: &str) -> Option<u32>` -- Read-only accessor for Phase 15.
    - `trip_count(&self, provider_name: &str) -> Option<u32>` -- Read-only accessor for Phase 15.

    **PermitType enum:**
    ```rust
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum PermitType {
        /// Normal request through a closed circuit.
        Normal,
        /// Probe request through a half-open circuit. Caller MUST use ProbeGuard.
        Probe,
    }
    ```

    **ProbeGuard RAII struct:**
    ```rust
    pub struct ProbeGuard<'a> {
        registry: &'a CircuitBreakerRegistry,
        provider: String,
        resolved: bool,
    }

    impl<'a> ProbeGuard<'a> {
        pub fn new(registry: &'a CircuitBreakerRegistry, provider: String) -> Self {
            Self { registry, provider, resolved: false }
        }
        pub fn success(mut self) {
            self.resolved = true;
            self.registry.record_probe_success(&self.provider);
        }
        pub fn failure(mut self, error_type: &str, message: &str) {
            self.resolved = true;
            self.registry.record_probe_failure(&self.provider, error_type, message);
        }
    }

    impl<'a> Drop for ProbeGuard<'a> {
        fn drop(&mut self) {
            if !self.resolved {
                tracing::warn!(provider = %self.provider, "ProbeGuard dropped without resolution, treating as failure");
                self.registry.record_probe_failure(&self.provider, "dropped", "probe dropped without resolution");
            }
        }
    }
    ```

    **Tests to add (in the existing #[cfg(test)] mod tests):**

    All use `#[tokio::test(start_paused = true)]`.

    1. `test_registry_new_creates_breakers` -- Create registry with 3 providers, verify all start Closed
    2. `test_registry_unknown_provider_allowed` -- acquire_permit for unknown name returns Ok
    3. `test_registry_acquire_permit_closed` -- Closed circuit returns Ok(Normal)
    4. `test_registry_acquire_permit_open_rejected` -- Trip circuit, acquire_permit returns Err(CircuitOpenError)
    5. `test_registry_record_success_resets` -- Record 2 failures, 1 success, 2 failures -> still Closed
    6. `test_registry_probe_permit_after_timeout` -- Trip, advance 31s, acquire_permit returns Ok(Probe)
    7. `test_registry_queue_and_wait_success` -- Trip circuit, advance 31s, first acquire gets Probe, spawn second acquire (blocks on WaitForProbe), record_probe_success, second acquire completes with Ok(Normal)
    8. `test_registry_queue_and_wait_failure` -- Same as above but record_probe_failure, second acquire receives CircuitOpenError
    9. `test_registry_multiple_waiters` -- 5 tasks waiting, probe succeeds, all 5 receive Ok
    10. `test_probe_guard_success` -- Create ProbeGuard, call .success(), verify circuit closes
    11. `test_probe_guard_failure` -- Create ProbeGuard, call .failure(), verify circuit reopens
    12. `test_probe_guard_drop_without_resolution` -- Create ProbeGuard, drop it, verify circuit reopens (RAII safety)
    13. `test_probe_result_reset_prevents_stale` -- Trip, recover, trip again, advance 31s -> waiters see correct (not stale) probe result
  </action>
  <verify>
    ```bash
    cargo test circuit_breaker -- --nocapture
    ```
    All tests pass including the new registry and queue-and-wait tests.
  </verify>
  <done>CircuitBreakerRegistry with DashMap, acquire_permit with queue-and-wait, ProbeGuard RAII, and 13+ new tests all passing.</done>
</task>

<task type="auto">
  <name>Task 2: Wire registry into AppState and add module re-exports</name>
  <files>src/proxy/mod.rs, src/proxy/server.rs</files>
  <action>
    **src/proxy/mod.rs:**
    Add re-exports for public types that Phase 14 and Phase 15 will consume:
    ```rust
    pub use circuit_breaker::{
        CircuitBreakerRegistry, CircuitOpenError, CircuitState, PermitType, ProbeGuard,
    };
    ```
    Note: `pub mod circuit_breaker;` should already exist from Plan 13-01. If not, add it.

    **src/proxy/server.rs:**
    1. Add `use super::circuit_breaker::CircuitBreakerRegistry;` import
    2. Add field to AppState:
       ```rust
       pub circuit_breakers: Arc<CircuitBreakerRegistry>,
       ```
    3. In `run_server()`, after creating the provider_router, initialize the registry:
       ```rust
       let provider_names: Vec<String> = config.providers.iter().map(|p| p.name.clone()).collect();
       let circuit_breakers = Arc::new(CircuitBreakerRegistry::new(&provider_names));
       ```
    4. Pass `circuit_breakers` to AppState construction.

    **Important:** The existing `create_router` function and handlers do NOT change in this plan. Phase 14 adds the handler-level integration. This plan only makes the registry available via AppState.

    **Also update any test helpers that construct AppState** (grep for `AppState {` in tests/ directory). Add `circuit_breakers: Arc::new(CircuitBreakerRegistry::new(&[]))` to test AppState construction so existing tests compile. Use empty provider list since existing tests don't exercise circuit breakers.
  </action>
  <verify>
    ```bash
    # Full test suite passes (no regressions from AppState change)
    cargo test

    # Clippy clean
    cargo clippy -- -D warnings

    # Verify re-exports compile
    cargo check
    ```
  </verify>
  <done>CircuitBreakerRegistry is initialized in AppState with one breaker per configured provider. Module re-exports allow Phase 14 and Phase 15 to import types directly from `crate::proxy`. All existing tests pass with updated AppState.</done>
</task>

</tasks>

<verification>
```bash
# All circuit breaker tests pass (both state machine and registry)
cargo test circuit_breaker -- --nocapture

# Full test suite passes (no regressions)
cargo test

# Clippy clean
cargo clippy -- -D warnings

# Build succeeds
cargo build
```
</verification>

<success_criteria>
- CircuitBreakerRegistry backed by DashMap with one entry per provider
- acquire_permit correctly returns Normal/Probe/Rejected and waits during HalfOpen probe
- Queue-and-wait: multiple blocked tasks all wake and receive correct result
- ProbeGuard RAII prevents stuck probe_in_flight on drop
- Watch channel reset to Pending after each probe cycle (no stale values)
- Registry wired into AppState with Arc for shared access
- Public re-exports in proxy/mod.rs for Phase 14/15 consumption
- All existing tests pass with updated AppState (no regressions)
- `cargo test` and `cargo clippy -- -D warnings` pass cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/13-circuit-breaker-state-machine/13-02-SUMMARY.md`
</output>
