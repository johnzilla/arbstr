---
phase: 05-secret-type-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/config.rs
  - src/router/selector.rs
  - src/proxy/handlers.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "Debug-formatting any struct containing an ApiKey shows [REDACTED], never the key value"
    - "Serializing any struct containing an ApiKey to JSON produces \"[REDACTED]\", never the key value"
    - "The /providers endpoint JSON includes api_key: \"[REDACTED]\" when a key is configured, api_key: null when not"
    - "The Authorization header sent to upstream providers contains the actual key value (not [REDACTED])"
    - "All existing tests pass with the new ApiKey type (no regressions)"
    - "secrecy crate provides zeroize-on-drop for ApiKey values"
    - "CLI providers command does not print any key information"
  artifacts:
    - path: "Cargo.toml"
      provides: "secrecy dependency added, config crate removed"
      contains: "secrecy"
    - path: "src/config.rs"
      provides: "ApiKey newtype with Debug/Display/Serialize/Deserialize/Clone"
      contains: "pub struct ApiKey"
      exports: ["ApiKey"]
    - path: "src/config.rs"
      provides: "ProviderConfig with Option<ApiKey> field"
      contains: "Option<ApiKey>"
    - path: "src/router/selector.rs"
      provides: "SelectedProvider with Option<ApiKey> field"
      contains: "Option<ApiKey>"
    - path: "src/proxy/handlers.rs"
      provides: "expose_secret() usage in Authorization header, redacted api_key in /providers"
      contains: "expose_secret"
    - path: "src/main.rs"
      provides: "Mock providers with ApiKey::from() keys"
      contains: "ApiKey::from"
  key_links:
    - from: "src/config.rs"
      to: "secrecy crate"
      via: "ApiKey wraps SecretString"
      pattern: "ApiKey\\(SecretString\\)"
    - from: "src/proxy/handlers.rs"
      to: "src/config.rs"
      via: "expose_secret() for Authorization header"
      pattern: "expose_secret\\(\\)"
    - from: "src/proxy/handlers.rs"
      to: "/providers JSON response"
      via: "conditional api_key field in JSON"
      pattern: "api_key.*REDACTED"
    - from: "src/router/selector.rs"
      to: "src/config.rs"
      via: "SelectedProvider.api_key cloned from ProviderConfig.api_key"
      pattern: "api_key.*clone"
---

<objective>
Migrate api_key from plaintext String to a SecretString-backed ApiKey newtype that redacts in Debug, Display, and Serialize, with zeroize-on-drop. Propagate the type change through all layers (config, router, proxy, CLI) and verify redaction works across all output surfaces.

Purpose: Protect API keys from accidental exposure in logs, JSON responses, and debug output (SEC-01, SEC-02, RED-02).
Output: All api_key fields use ApiKey type; all output surfaces show [REDACTED]; existing tests pass.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-secret-type-foundation/05-CONTEXT.md
@.planning/phases/05-secret-type-foundation/05-RESEARCH.md
@Cargo.toml
@src/config.rs
@src/router/selector.rs
@src/proxy/handlers.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define ApiKey type and propagate through all layers</name>
  <files>
    Cargo.toml
    src/config.rs
    src/router/selector.rs
    src/proxy/handlers.rs
    src/main.rs
  </files>
  <action>
**Cargo.toml changes:**
- Add dependency: `secrecy = { version = "0.10", features = ["serde"] }`
- Remove unused dependency: `config = "0.14"` (never imported anywhere in source)

**src/config.rs — Define ApiKey newtype:**

Add these imports at the top:
```rust
use secrecy::{ExposeSecret, SecretString};
use serde::{Serialize, Serializer, Deserializer};
```

Define the ApiKey type (place above ProviderConfig):
```rust
/// API key wrapper that redacts in Debug/Display/Serialize and zeroizes on drop.
///
/// The inner `SecretString` ensures the key value is:
/// - Zeroized in memory when dropped (SEC-02)
/// - Never exposed via Debug or Display (SEC-01)
/// - Only accessible via `.expose_secret()` (grep-auditable)
#[derive(Clone)]
pub struct ApiKey(SecretString);

impl ApiKey {
    /// Access the raw key value. Every call site is auditable via `grep expose_secret`.
    pub fn expose_secret(&self) -> &str {
        self.0.expose_secret()
    }
}

impl std::fmt::Debug for ApiKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[REDACTED]")
    }
}

impl std::fmt::Display for ApiKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[REDACTED]")
    }
}

impl Serialize for ApiKey {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        serializer.serialize_str("[REDACTED]")
    }
}

impl<'de> serde::Deserialize<'de> for ApiKey {
    fn deserialize<D: Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        SecretString::deserialize(deserializer).map(ApiKey)
    }
}

impl From<String> for ApiKey {
    fn from(s: String) -> Self {
        ApiKey(SecretString::from(s))
    }
}

impl From<&str> for ApiKey {
    fn from(s: &str) -> Self {
        ApiKey(SecretString::from(s))
    }
}
```

Change `ProviderConfig.api_key` from `Option<String>` to `Option<ApiKey>`. The struct keeps `#[derive(Debug, Clone, Deserialize)]` — derive(Debug) will use ApiKey's custom Debug impl automatically. Note: do NOT add Serialize to ProviderConfig's derive (it does not currently derive Serialize).

**src/router/selector.rs — Update SelectedProvider:**

Add import: `use crate::config::ApiKey;`
Change `SelectedProvider.api_key` from `Option<String>` to `Option<ApiKey>`.
The `From<&ProviderConfig>` impl clones api_key — this works because ApiKey derives Clone.

**src/proxy/handlers.rs — Two changes:**

1. In `send_to_provider`, change the Authorization header line from:
   `format!("Bearer {}", api_key)` to `format!("Bearer {}", api_key.expose_secret())`
   This is the ONE place the real key value must appear.

2. In `list_providers`, update the JSON construction to include the api_key field. Change the `.map(|p| { ... })` closure to:
   ```rust
   .map(|p| {
       serde_json::json!({
           "name": p.name,
           "models": p.models,
           "input_rate_sats_per_1k": p.input_rate,
           "output_rate_sats_per_1k": p.output_rate,
           "base_fee_sats": p.base_fee,
           "api_key": if p.api_key.is_some() {
               serde_json::Value::String("[REDACTED]".to_string())
           } else {
               serde_json::Value::Null
           },
       })
   })
   ```

**src/main.rs — Update mock_config():**

Per user decision "Mock providers use SecretString too": change mock providers to use `Some(ApiKey::from("mock-test-key-cheap"))` and `Some(ApiKey::from("mock-test-key-expensive"))` instead of `api_key: None`.
Add import in the `mock_config` function's `use arbstr::config::*;` block — ApiKey is already covered by the wildcard import.

**IMPORTANT: The CLI `providers` command already does NOT print api_key info. No change needed there.** The current code in the Providers match arm already only prints name, url, models, rates, and base_fee. Per user decision: "CLI providers command removes the key column entirely — a column of identical [REDACTED] adds no value."

After all changes, the only `expose_secret()` call site should be the Authorization header in `send_to_provider`. Verify with grep.
  </action>
  <verify>
Run `cargo build` — must compile with zero errors.
Run `cargo clippy -- -D warnings` — no new warnings.
Run `grep -r "expose_secret" src/` — should show exactly ONE call site in src/proxy/handlers.rs.
Run `grep -r "config = " Cargo.toml` — should NOT find the old config dependency.
  </verify>
  <done>
Project compiles. ApiKey type defined with Debug/Display/Serialize/Deserialize/Clone. All api_key fields use Option<ApiKey>. expose_secret() used only for Authorization header. config crate removed from Cargo.toml.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add redaction tests and verify no regressions</name>
  <files>
    src/config.rs
  </files>
  <action>
Add the following tests to the existing `#[cfg(test)] mod tests` block in `src/config.rs`:

```rust
#[test]
fn test_api_key_debug_redaction() {
    let key = ApiKey::from("super-secret-cashu-token");
    let debug_output = format!("{:?}", key);
    assert_eq!(debug_output, "[REDACTED]");
    assert!(!debug_output.contains("super-secret"));
}

#[test]
fn test_api_key_display_redaction() {
    let key = ApiKey::from("super-secret-cashu-token");
    let display_output = format!("{}", key);
    assert_eq!(display_output, "[REDACTED]");
    assert!(!display_output.contains("super-secret"));
}

#[test]
fn test_api_key_serialize_redaction() {
    let key = ApiKey::from("real-secret-value");
    let json = serde_json::to_string(&key).unwrap();
    assert_eq!(json, "\"[REDACTED]\"");
    assert!(!json.contains("real-secret"));
}

#[test]
fn test_api_key_deserialize_from_string() {
    let key: ApiKey = serde_json::from_str("\"my-secret-key\"").unwrap();
    assert_eq!(key.expose_secret(), "my-secret-key");
}

#[test]
fn test_api_key_expose_secret() {
    let key = ApiKey::from("the-actual-value");
    assert_eq!(key.expose_secret(), "the-actual-value");
}

#[test]
fn test_provider_config_debug_redaction() {
    let config = ProviderConfig {
        name: "test".to_string(),
        url: "https://example.com/v1".to_string(),
        api_key: Some(ApiKey::from("cashuABCD1234secret")),
        models: vec![],
        input_rate: 10,
        output_rate: 30,
        base_fee: 1,
    };
    let debug_output = format!("{:?}", config);
    assert!(debug_output.contains("[REDACTED]"), "Debug output should contain [REDACTED]");
    assert!(!debug_output.contains("cashuABCD1234secret"), "Debug output must not contain actual key");
}

#[test]
fn test_api_key_toml_deserialization() {
    let toml = r#"
        [server]
        listen = "127.0.0.1:9000"

        [[providers]]
        name = "test-provider"
        url = "https://example.com/v1"
        api_key = "cashuABCD1234secret"
        models = ["gpt-4o"]
        input_rate = 10
        output_rate = 30
        base_fee = 1
    "#;

    let config = Config::parse_str(toml).unwrap();
    assert_eq!(config.providers[0].api_key.as_ref().unwrap().expose_secret(), "cashuABCD1234secret");
    // Verify Debug doesn't leak
    let debug = format!("{:?}", config.providers[0]);
    assert!(!debug.contains("cashuABCD1234secret"));
    assert!(debug.contains("[REDACTED]"));
}

#[test]
fn test_provider_config_without_api_key() {
    let toml = r#"
        [server]
        listen = "127.0.0.1:9000"

        [[providers]]
        name = "no-key-provider"
        url = "https://example.com/v1"
        models = ["gpt-4o"]
    "#;

    let config = Config::parse_str(toml).unwrap();
    assert!(config.providers[0].api_key.is_none());
}
```

Add `use serde_json;` to the test module imports if not already present (serde_json is a dependency so it's available).

Also update the existing `test_parse_full_config` test: the existing test constructs a TOML without api_key and that's fine — it still works with Option<ApiKey>. No change needed to existing tests.

After adding tests, update any existing test in `src/router/selector.rs` that constructs `ProviderConfig` with `api_key: None` — these should still compile since `None` works for `Option<ApiKey>`. No changes needed to those tests.
  </action>
  <verify>
Run `cargo test` — ALL tests must pass (both new and existing).
Run `cargo test -- test_api_key` — all 8 new ApiKey tests pass.
Run `cargo fmt -- --check` — code is formatted.
Run `cargo clippy -- -D warnings` — no warnings.
  </verify>
  <done>
8 new tests verify: Debug redaction, Display redaction, Serialize redaction, Deserialize roundtrip, expose_secret access, ProviderConfig Debug propagation, TOML deserialization with ApiKey, and provider without api_key. All existing tests pass with no modifications (no regressions). cargo fmt and clippy clean.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles successfully
2. `cargo test` — all tests pass (existing + 8 new)
3. `cargo clippy -- -D warnings` — clean
4. `grep -rn "expose_secret" src/` — exactly 1 call site (Authorization header in handlers.rs) plus the ApiKey impl in config.rs
5. `grep -rn "api_key" src/proxy/handlers.rs` — list_providers includes "[REDACTED]" field, send_to_provider uses expose_secret()
6. No occurrence of a raw key string in any Debug/Display/Serialize output path
</verification>

<success_criteria>
- ApiKey newtype wraps secrecy::SecretString with custom Debug ("[REDACTED]"), Display ("[REDACTED]"), Serialize ("[REDACTED]"), delegated Deserialize, and zeroize-on-drop
- ProviderConfig.api_key and SelectedProvider.api_key use Option<ApiKey>
- Authorization header uses expose_secret() — the only place the real value surfaces
- /providers endpoint JSON includes "api_key": "[REDACTED]" (when key present) or "api_key": null (when absent)
- CLI providers command does not print key info (unchanged, already correct)
- Mock providers use Some(ApiKey::from("mock-test-key-..."))
- config crate removed from Cargo.toml, secrecy crate added
- All 8 new tests + all existing tests pass
- Zero clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/05-secret-type-foundation/05-01-SUMMARY.md`
</output>
