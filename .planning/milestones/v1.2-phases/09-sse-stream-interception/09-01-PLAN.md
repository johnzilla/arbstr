---
phase: 09-sse-stream-interception
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/proxy/stream.rs
autonomous: true

must_haves:
  truths:
    - "SSE data lines split across TCP chunk boundaries are reassembled correctly without data loss"
    - "The usage object (prompt_tokens, completion_tokens) is extracted from the final SSE chunk when present"
    - "finish_reason is extracted from the last chunk that contains one"
    - "Streams without usage data pass through without error, yielding no extracted values"
    - "Streams that end without [DONE] return an empty result (no usage, no finish_reason)"
    - "Non-data SSE lines (event:, id:, retry:, comments) are skipped without error"
    - "Malformed JSON in data lines is skipped with a warning; extraction continues"
  artifacts:
    - path: "src/proxy/stream.rs"
      provides: "SseObserver, StreamResult, StreamUsage types and line-buffered extraction logic"
      contains: "struct SseObserver"
  key_links:
    - from: "src/proxy/stream.rs"
      to: "serde_json::Value"
      via: "JSON parsing of data: lines for usage extraction"
      pattern: "serde_json::from_str"
---

<objective>
Implement the SseObserver core: types, line buffer, and usage/finish_reason extraction with comprehensive TDD coverage.

Purpose: This is the heart of Phase 9 -- a line-buffered SSE parser that correctly handles TCP chunk boundaries and extracts usage data from the final chunk. TDD ensures every edge case (split lines, no-DONE, malformed JSON, CRLF) is covered by tests before integration.

Output: `src/proxy/stream.rs` with StreamResult, StreamUsage, SseObserver types and all unit tests passing.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-sse-stream-interception/09-RESEARCH.md
@src/proxy/handlers.rs (lines 670-716 for existing stream pattern)
@src/proxy/types.rs (StreamOptions, Usage types for reference)
</context>

<feature>
  <name>SseObserver line-buffered extraction</name>
  <files>src/proxy/stream.rs</files>
  <behavior>
    SseObserver buffers raw bytes across chunk boundaries, reassembles complete SSE lines, and extracts usage + finish_reason from data: lines.

    Cases:
    - Single chunk with full stream -> extracts usage, finish_reason, done_received=true
    - Usage JSON split across two chunks at arbitrary byte position -> correctly reassembles and extracts
    - Stream with no usage (all null) + [DONE] -> done_received=true, usage=None
    - Stream ending without [DONE] -> empty result (usage=None, finish_reason=None, done_received=false)
    - Data line with malformed JSON -> skipped, extraction continues for subsequent lines
    - Non-data SSE fields (event:, id:, retry:, comments) -> skipped silently
    - Both \n and \r\n line endings -> handled correctly
    - data: with and without space after colon -> both parsed
    - [DONE] without trailing newline (final buffer flush) -> done_received=true
    - Empty stream (no chunks) -> empty result
  </behavior>
  <implementation>
    Create src/proxy/stream.rs with:

    1. **StreamUsage** struct: prompt_tokens (u32), completion_tokens (u32). Derive Debug, Clone, PartialEq, Eq.

    2. **StreamResult** struct: usage (Option of StreamUsage), finish_reason (Option of String), done_received (bool). Derive Debug, Clone. Include StreamResult::empty() constructor.

    3. **SseObserver** struct (pub(crate) visibility):
       - buffer: Vec of u8
       - usage: Option of StreamUsage
       - finish_reason: Option of String
       - done_received: bool

    4. **SseObserver::new()** -- initialize with empty buffer and None/false fields.

    5. **SseObserver::process_chunk(&mut self, bytes: &[u8])** -- append bytes to buffer, scan for complete lines (\n), handle \r\n by trimming \r before \n. For each complete line, call process_line. Retain trailing incomplete bytes. Cap buffer at 64KB -- if exceeded, drain entirely and log warn.

    6. **SseObserver::process_line(&mut self, line: &str)** -- skip empty lines (SSE event delimiter). Skip comment lines starting with ':' (log trace). Skip event:/id:/retry: lines (log trace). For data: lines (with or without space after colon), call process_data.

    7. **SseObserver::process_data(&mut self, data: &str)** -- trim data. If "[DONE]", set done_received=true. Otherwise parse as serde_json::Value. On parse error, log warn and return. Extract finish_reason from choices[0].finish_reason if non-null string. Extract usage from usage object if non-null (prompt_tokens, completion_tokens as u32). Log warn if usage object present but fields missing.

    8. **SseObserver::flush_buffer(&mut self)** -- process any remaining content in the buffer as a final line (handles [DONE] without trailing newline). Called by into_result before building result.

    9. **SseObserver::into_result(mut self) -> StreamResult** -- call flush_buffer, then if !done_received return StreamResult::empty(), else return StreamResult with usage/finish_reason/done_received=true.

    Tests (in #[cfg(test)] mod tests at bottom of stream.rs):

    RED phase -- write all tests first, they fail because types/methods don't exist:
    - test_single_chunk_full_stream: full SSE stream in one chunk, verify usage + finish_reason + done_received
    - test_usage_split_across_chunks: usage JSON line split at multiple byte positions, verify correct extraction
    - test_no_usage_with_done: stream with null usage on all chunks + [DONE], verify done=true, usage=None
    - test_no_done_returns_empty: stream that ends without [DONE], verify empty result
    - test_malformed_json_skipped: bad JSON data line followed by valid usage chunk + [DONE], verify usage extracted
    - test_non_data_sse_fields_skipped: stream with event:/id:/retry:/comment lines, verify no error and extraction works
    - test_crlf_line_endings: same stream with \r\n instead of \n, verify correct extraction
    - test_data_without_space: data:{"json"} (no space after colon), verify parsed
    - test_done_without_trailing_newline: [DONE] as last bytes with no \n, verify done_received via flush
    - test_empty_stream: no chunks processed, verify empty result
    - test_finish_reason_extracted: stream with finish_reason:"stop" on content chunk, verify extraction
    - test_buffer_cap: chunk exceeding 64KB, verify buffer is drained and processing continues

    Use a helper function split_sse_at_positions(events, positions) -> Vec of Vec of u8 for building chunk-boundary test fixtures.

    GREEN phase -- implement all types and methods to pass tests.

    REFACTOR phase -- clean up if needed (DRY the test helper, tighten visibility).
  </implementation>
</feature>

<verification>
```bash
cargo test --lib proxy::stream -- --nocapture
```
All tests pass. No compiler warnings.
```bash
cargo clippy -- -D warnings
```
No clippy warnings.
</verification>

<success_criteria>
- All 12+ unit tests pass covering every edge case listed in behavior
- SseObserver correctly handles chunk boundary splits (verified by split_sse_at_positions tests)
- Streams without [DONE] return StreamResult::empty()
- Malformed JSON is skipped without affecting subsequent extraction
- Both \n and \r\n line endings work
- cargo clippy clean
</success_criteria>

<output>
After completion, create `.planning/phases/09-sse-stream-interception/09-01-SUMMARY.md`
</output>
