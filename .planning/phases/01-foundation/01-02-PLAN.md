---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/proxy/server.rs
autonomous: true

must_haves:
  truths:
    - "Every HTTP request to the proxy generates a unique UUID v4 visible in structured logs"
    - "The request_id field appears on the tracing span wrapping the entire request lifecycle"
    - "Different requests produce different request_id values"
    - "Existing server functionality is unchanged (endpoints, middleware ordering)"
  artifacts:
    - path: "src/proxy/server.rs"
      provides: "TraceLayer with make_span_with generating per-request UUID"
      contains: "make_span_with"
  key_links:
    - from: "src/proxy/server.rs"
      to: "uuid::Uuid"
      via: "Uuid::new_v4() in make_span_with closure"
      pattern: "Uuid::new_v4"
    - from: "TraceLayer"
      to: "tracing::info_span"
      via: "make_span_with closure creates span with request_id field"
      pattern: "request_id"
---

<objective>
Add per-request correlation IDs to the proxy server via TraceLayer's make_span_with.

Purpose: Every proxied request needs a unique ID for tracing across logs. This is the foundation for Phase 2 (SQLite logging) and Phase 3 (response headers). The ID is internal to arbstr -- it is NOT forwarded to upstream providers and NOT read from client headers.

Output: Updated `create_router` function in `src/proxy/server.rs` with TraceLayer configured to generate UUID v4 per request.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/proxy/server.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure TraceLayer with per-request UUID correlation ID</name>
  <files>src/proxy/server.rs</files>
  <action>
    Modify `create_router` in `src/proxy/server.rs` to replace the bare `TraceLayer::new_for_http()` with a configured TraceLayer that generates a UUID v4 per request.

    Specific changes:

    1. Add imports at the top of the file:
       - `use uuid::Uuid;`
       - `use tower_http::trace::TraceLayer;` is already imported -- keep it

    2. Replace `.layer(TraceLayer::new_for_http())` with:
       ```rust
       .layer(
           TraceLayer::new_for_http()
               .make_span_with(|request: &http::Request<axum::body::Body>| {
                   let request_id = Uuid::new_v4();
                   tracing::info_span!(
                       "request",
                       method = %request.method(),
                       uri = %request.uri(),
                       request_id = %request_id,
                   )
               })
       )
       ```

    3. Import `http` if not already available. axum re-exports `http` types, so use `axum::http::Request` or add `use axum::http;` -- check what's already imported and be consistent.

    Important constraints:
    - Keep TraceLayer as the LAST .layer() call (outermost middleware) -- it already is
    - Use `info_span!` not `debug_span!` so the span shows at default log level
    - Do NOT add the request_id as an axum extension (Phase 3 concern)
    - Do NOT forward the ID to upstream providers
    - Do NOT read X-Request-ID from client headers -- arbstr controls the ID

    After making changes, run:
    - `cargo build` to verify compilation
    - `cargo test` to verify no regressions
    - `cargo clippy -- -D warnings` to verify no lint issues
  </action>
  <verify>
    ```bash
    # Compiles cleanly
    cargo build 2>&1 | tail -5

    # All existing tests still pass
    cargo test

    # No clippy warnings
    cargo clippy -- -D warnings

    # Verify make_span_with is present
    grep -n "make_span_with" src/proxy/server.rs

    # Verify Uuid::new_v4 is used
    grep -n "Uuid::new_v4" src/proxy/server.rs

    # Verify request_id is in the span
    grep -n "request_id" src/proxy/server.rs

    # Verify info_span (not debug_span)
    grep -n "info_span" src/proxy/server.rs
    ```
  </verify>
  <done>
    - `make_span_with` closure generates UUID v4 and attaches it as `request_id` field on an `info_span!("request", ...)` span
    - `cargo build` succeeds
    - `cargo test` passes all existing tests (5 tests)
    - `cargo clippy -- -D warnings` produces no warnings
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify correlation ID appears in log output</name>
  <files>src/proxy/server.rs</files>
  <action>
    Run the proxy in mock mode with debug logging and make a test request to confirm the correlation ID appears in structured log output.

    Steps:
    1. Start the server: `RUST_LOG=arbstr=debug,tower_http=debug cargo run -- serve --mock &`
    2. Wait 2 seconds for startup
    3. Make a health check request: `curl -s http://127.0.0.1:8080/health`
    4. Make a chat completion request:
       ```bash
       curl -s http://127.0.0.1:8080/v1/chat/completions \
         -H "Content-Type: application/json" \
         -d '{"model": "gpt-4o", "messages": [{"role": "user", "content": "hello"}]}'
       ```
    5. Check the server logs for `request_id` field -- it should appear as a UUID string in the structured log output
    6. Kill the background server process

    Note: If mock mode doesn't have providers configured, the chat completion may return an error -- that's fine, the correlation ID should still appear in the request span logs regardless of whether the request succeeds.

    If the server fails to start (e.g., port in use), try a different port or just rely on the compilation and grep verification from Task 1. This task is a smoke test, not a hard requirement.
  </action>
  <verify>
    Server log output contains a UUID-format string in the request_id field for each request.

    If smoke test can't run (port in use, mock mode issues), fall back to verifying:
    ```bash
    # Confirm the span includes request_id
    grep -A5 "make_span_with" src/proxy/server.rs | grep "request_id"
    ```
  </verify>
  <done>
    Correlation ID (UUID v4 format) appears in structured log output for HTTP requests, OR the code structure is confirmed correct via static analysis if the smoke test cannot run.
  </done>
</task>

</tasks>

<verification>
```bash
# All tests pass
cargo test

# No warnings
cargo clippy -- -D warnings

# Code compiles
cargo build

# make_span_with with UUID exists
grep "make_span_with" src/proxy/server.rs
grep "Uuid::new_v4" src/proxy/server.rs
grep "request_id" src/proxy/server.rs
```
</verification>

<success_criteria>
- TraceLayer configured with `make_span_with` generating UUID v4 per request
- `request_id` field on `info_span!("request", ...)` span
- All existing tests pass (no regressions)
- `cargo clippy` clean
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
