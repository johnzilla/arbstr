---
phase: 15-enhanced-health-endpoint
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/proxy/circuit_breaker.rs
  - src/proxy/handlers.rs
  - tests/health.rs
autonomous: true
requirements:
  - HLT-01
  - HLT-02

must_haves:
  truths:
    - "GET /health returns JSON with per-provider circuit state and failure_count"
    - "Top-level status is 'ok' when all circuits are closed"
    - "Top-level status is 'degraded' when some circuits are open or half-open"
    - "Top-level status is 'unhealthy' (HTTP 503) when all circuits are open"
    - "Zero configured providers returns 'ok' with empty providers object"
    - "Half-open providers count as degraded, not unhealthy"
  artifacts:
    - path: "src/proxy/circuit_breaker.rs"
      provides: "CircuitSnapshot struct and all_states() method on CircuitBreakerRegistry"
      contains: "fn all_states"
    - path: "src/proxy/handlers.rs"
      provides: "Enhanced health handler with HealthResponse, ProviderHealth, compute_status"
      contains: "struct HealthResponse"
    - path: "tests/health.rs"
      provides: "Integration tests for /health endpoint covering all status tiers"
      min_lines: 100
  key_links:
    - from: "src/proxy/handlers.rs"
      to: "src/proxy/circuit_breaker.rs"
      via: "state.circuit_breakers.all_states()"
      pattern: "all_states\\(\\)"
    - from: "src/proxy/handlers.rs"
      to: "src/proxy/server.rs"
      via: "State(state): State<AppState> extractor"
      pattern: "State\\(state\\)"
---

<objective>
Replace the existing trivial `/health` endpoint with an enhanced version that reports per-provider circuit breaker state and a computed top-level health status.

Purpose: Operators can see which providers are healthy, degraded, or down at a glance via a single HTTP call.
Output: Enhanced GET /health endpoint with per-provider circuit state, integration tests proving all status tiers.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-enhanced-health-endpoint/15-RESEARCH.md
@src/proxy/circuit_breaker.rs
@src/proxy/handlers.rs
@src/proxy/server.rs
@tests/circuit_integration.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add all_states() to CircuitBreakerRegistry and implement enhanced health handler</name>
  <files>src/proxy/circuit_breaker.rs, src/proxy/handlers.rs</files>
  <action>
**In `src/proxy/circuit_breaker.rs`:**

1. Add a `CircuitSnapshot` struct (public, derive Debug):
   ```rust
   /// Snapshot of a single provider's circuit breaker state.
   #[derive(Debug)]
   pub struct CircuitSnapshot {
       pub name: String,
       pub state: CircuitState,
       pub failure_count: u32,
   }
   ```

2. Add `all_states()` method to `CircuitBreakerRegistry`:
   ```rust
   /// Return a snapshot of all provider circuit states.
   ///
   /// Uses DashMap::iter() which acquires per-shard locks (not a global lock).
   pub fn all_states(&self) -> Vec<CircuitSnapshot> {
       self.breakers
           .iter()
           .map(|entry| {
               let inner = entry.value().inner.lock().unwrap();
               CircuitSnapshot {
                   name: entry.key().clone(),
                   state: inner.state,
                   failure_count: inner.failure_count,
               }
           })
           .collect()
   }
   ```

3. Add `as_str()` method to `CircuitState`:
   ```rust
   impl CircuitState {
       /// Lowercase string representation for JSON serialization.
       pub fn as_str(&self) -> &'static str {
           match self {
               CircuitState::Closed => "closed",
               CircuitState::Open => "open",
               CircuitState::HalfOpen => "half_open",
           }
       }
   }
   ```

4. Export `CircuitSnapshot` from `proxy/mod.rs` in the existing `pub use circuit_breaker::{...}` line.

**In `src/proxy/handlers.rs`:**

1. Add response structs (use `serde::Serialize`, `std::collections::HashMap`):
   ```rust
   #[derive(Debug, Serialize)]
   pub struct HealthResponse {
       pub status: String,
       pub providers: HashMap<String, ProviderHealth>,
   }

   #[derive(Debug, Serialize)]
   pub struct ProviderHealth {
       pub state: String,
       pub failure_count: u32,
   }
   ```

2. Replace the existing `health()` handler. Change signature from `pub async fn health() -> impl IntoResponse` to `pub async fn health(State(state): State<AppState>) -> impl IntoResponse`. The handler:
   - Calls `state.circuit_breakers.all_states()` to get all circuit snapshots
   - Builds a `HashMap<String, ProviderHealth>` from the snapshots (use `CircuitState::as_str()` for state string)
   - Computes the top-level status and HTTP status code using this logic:
     - If snapshots is empty: `("ok", StatusCode::OK)`
     - If ALL circuits are `CircuitState::Open`: `("unhealthy", StatusCode::SERVICE_UNAVAILABLE)`
     - If ANY circuit is `Open` or `HalfOpen`: `("degraded", StatusCode::OK)`
     - Otherwise (all closed): `("ok", StatusCode::OK)`
   - Returns `(status_code, Json(HealthResponse { status, providers }))` — the tuple form lets axum set the HTTP status code

3. The route in `server.rs` does NOT need updating — axum resolves `State(state)` automatically from `.with_state(state)`.

**Important:** Do NOT add the `"service": "arbstr"` field to the response — the locked decision specifies only `status` and `providers` at the top level.
  </action>
  <verify>
Run `cargo build` to confirm compilation. Run `cargo clippy -- -D warnings` to confirm no lint issues. Run `cargo test` to confirm no regressions in existing tests.
  </verify>
  <done>
The health handler compiles, accepts State extractor, returns JSON with `status` and `providers` fields, and all existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for /health endpoint</name>
  <files>tests/health.rs</files>
  <action>
Create `tests/health.rs` with integration tests for the enhanced `/health` endpoint. Reuse the `setup_circuit_test_app` and `trip_circuit` patterns from `tests/circuit_integration.rs`.

**Test helpers** (copy setup pattern from circuit_integration.rs):
- `setup_circuit_test_app(providers) -> (Router, Arc<CircuitBreakerRegistry>)` — same as circuit_integration.rs
- `trip_circuit(registry, provider_name)` — same as circuit_integration.rs
- `parse_body(response) -> (StatusCode, serde_json::Value)` — same as circuit_integration.rs

**Required tests (8 tests):**

1. `test_health_ok_all_closed` — Two providers, both circuits closed. Assert HTTP 200, `status == "ok"`, providers object has both entries with `state: "closed"` and `failure_count: 0`.

2. `test_health_ok_zero_providers` — Empty providers vec. Assert HTTP 200, `status == "ok"`, `providers` is empty object `{}`.

3. `test_health_degraded_one_open` — Two providers, trip one circuit to Open. Assert HTTP 200, `status == "degraded"`, the tripped provider has `state: "open"` and `failure_count: 3`, the healthy provider has `state: "closed"` and `failure_count: 0`.

4. `test_health_unhealthy_all_open` — Two providers, trip both circuits. Assert HTTP 503, `status == "unhealthy"`, both providers have `state: "open"`.

5. `test_health_degraded_half_open` — One provider, trip circuit, then advance time past 30s timeout and call `acquire_permit` to trigger lazy Half-Open transition. Assert HTTP 200, `status == "degraded"`, provider has `state: "half_open"`. Use `#[tokio::test(start_paused = true)]` and `tokio::time::advance(Duration::from_secs(31))` for deterministic time control.

6. `test_health_degraded_mix_open_half_open` — Two providers, trip both, advance time so one becomes half-open (acquire_permit on one). Assert HTTP 200, `status == "degraded"` (not unhealthy — half-open is not open).

7. `test_health_single_provider_open` — One provider, trip circuit. Assert HTTP 503, `status == "unhealthy"` (all = 1 provider is open).

8. `test_health_failure_count_increments` — One provider, record 2 failures (below threshold). Assert HTTP 200, `status == "ok"`, `state: "closed"`, `failure_count: 2`.

**Provider config pattern** (reuse from circuit_integration.rs):
```rust
ProviderConfig {
    name: "provider-a".to_string(),
    url: "https://fake.test/v1".to_string(),
    api_key: None,
    models: vec!["gpt-4o".to_string()],
    input_rate: 5,
    output_rate: 15,
    base_fee: 0,
}
```

**Request construction:**
```rust
let request = Request::get("/health").body(Body::empty()).unwrap();
let response = app.oneshot(request).await.unwrap();
```

**Assertion pattern for provider entries:** Access providers by name via `json["providers"]["provider-a"]`. Do NOT assert on ordering of the providers object — DashMap iteration is non-deterministic.

**For half-open tests:** After tripping the circuit, use `tokio::time::advance(Duration::from_secs(31)).await` then call `registry.acquire_permit("provider-name").await` to trigger the lazy Closed->HalfOpen transition. The acquire_permit call is needed because the transition only happens on the next check.
  </action>
  <verify>
Run `cargo test --test health` to confirm all 8 tests pass. Run `cargo test` to confirm no regressions across the full test suite.
  </verify>
  <done>
All 8 integration tests pass, covering: ok (all closed), ok (zero providers), degraded (some open), degraded (half-open), unhealthy (all open), and failure count tracking. Full test suite remains green.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without errors
2. `cargo clippy -- -D warnings` has no warnings
3. `cargo test` — all existing tests pass (no regressions)
4. `cargo test --test health` — all 8 new health endpoint tests pass
5. Manual verification: `curl http://127.0.0.1:8080/health` returns JSON with `status` and `providers` fields (optional, requires running server)
</verification>

<success_criteria>
- GET /health returns `{"status": "ok", "providers": {"name": {"state": "closed", "failure_count": 0}}}` when all circuits closed
- GET /health returns `{"status": "degraded", ...}` with HTTP 200 when some circuits are open or half-open
- GET /health returns `{"status": "unhealthy", ...}` with HTTP 503 when ALL circuits are open
- GET /health returns `{"status": "ok", "providers": {}}` with HTTP 200 when zero providers configured
- Half-open providers cause "degraded" status, not "unhealthy"
- 8 integration tests cover all status tiers and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/15-enhanced-health-endpoint/15-01-SUMMARY.md`
</output>
