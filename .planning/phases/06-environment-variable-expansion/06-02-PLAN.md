---
phase: 06-environment-variable-expansion
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "Startup logs show per-provider key source without revealing key values"
    - "cargo run -- check -c config.toml reports per-provider key availability and source"
    - "serve command uses env-var-aware config loading (from_file_with_env)"
    - "check command uses env-var-aware config loading (from_file_with_env)"
    - "providers command uses env-var-aware config loading (from_file_with_env)"
    - "Mock mode still works unchanged (no env var expansion needed)"
  artifacts:
    - path: "src/main.rs"
      provides: "Updated serve, check, providers commands using from_file_with_env"
      contains: "from_file_with_env"
  key_links:
    - from: "Commands::Serve"
      to: "Config::from_file_with_env"
      via: "calls from_file_with_env instead of from_file for real config"
      pattern: "from_file_with_env"
    - from: "Commands::Check"
      to: "Config::from_file_with_env"
      via: "calls from_file_with_env and reports key_sources"
      pattern: "from_file_with_env"
    - from: "Commands::Serve"
      to: "tracing::info"
      via: "logs KeySource per provider at startup"
      pattern: "key from"
---

<objective>
Wire the env-var-aware config loading into all CLI commands and add key source reporting at startup and in the check command.

Purpose: This completes ENV-04 (startup key source logging) and ENV-05 (check command reporting), making the expansion engine user-visible.
Output: Updated src/main.rs where serve/check/providers commands use from_file_with_env, startup logs per-provider key sources, and check command reports key availability.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-environment-variable-expansion/06-RESEARCH.md
@.planning/phases/06-environment-variable-expansion/06-01-PLAN.md
@src/main.rs
@src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update CLI commands to use env-var-aware config loading with key source reporting</name>
  <files>src/main.rs</files>
  <action>
Update src/main.rs to use Config::from_file_with_env instead of Config::from_file for all three commands. Import KeySource from config module.

**1. Update serve command (non-mock path):**

Replace `Config::from_file(&config_path)?` with:
```rust
let (config, key_sources) = Config::from_file_with_env(&config_path)?;
```

After the "Configuration loaded" tracing::info, add per-provider key source logging (ENV-04):
```rust
for (provider_name, source) in &key_sources {
    match source {
        KeySource::Literal => tracing::info!(provider = %provider_name, "key from config-literal"),
        KeySource::EnvExpanded => tracing::info!(provider = %provider_name, "key from env-expanded"),
        KeySource::Convention(var) => tracing::info!(provider = %provider_name, env_var = %var, "key from convention"),
        KeySource::None => tracing::warn!(provider = %provider_name, "no api key available"),
    }
}
```

Note: The mock path still uses `mock_config()` directly -- no key source logging needed for mock mode.

**2. Update check command (ENV-05):**

Replace `Config::from_file(&config_path)` with:
```rust
let (config, key_sources) = Config::from_file_with_env(&config_path)?;
```

After printing provider count and policy rules, add key availability reporting:
```rust
println!();
println!("Provider key status:");
for (name, source) in &key_sources {
    match source {
        KeySource::Literal => println!("  {}: key from config-literal", name),
        KeySource::EnvExpanded => println!("  {}: key from env-expanded", name),
        KeySource::Convention(var) => println!("  {}: key from convention ({})", name, var),
        KeySource::None => {
            let expected = arbstr::config::convention_env_var_name(name);
            println!("  {}: no key (set {} or add api_key to config)", name, expected);
        }
    }
}
```

For the None case, report the expected convention env var name so users know what to set. Use the public convention_env_var_name function from config.rs.

**3. Update providers command:**

Replace `Config::from_file(&config_path)?` with:
```rust
let (config, _key_sources) = Config::from_file_with_env(&config_path)?;
```

The providers command already shows provider info. No key source display needed here (Phase 7 handles masked key display).

**4. Update imports:**

Add `KeySource` to the existing `use arbstr::config::Config` import:
```rust
use arbstr::config::{Config, KeySource};
```

Also import `convention_env_var_name` if needed for the check command:
```rust
use arbstr::config::convention_env_var_name;
```
Or call it as `arbstr::config::convention_env_var_name(name)` inline.

**IMPORTANT:** Keep the mock_config() function unchanged. Mock mode bypasses file loading entirely.
**IMPORTANT:** The error handling for from_file_with_env should use `?` operator -- ConfigError already converts to anyhow::Error via the Error::Config variant, and the check command's match arm handles the error case.

For the check command specifically: the current code uses `match Config::from_file(...)` with Ok/Err arms. Update to:
```rust
Commands::Check { config: config_path } => {
    match Config::from_file_with_env(&config_path) {
        Ok((config, key_sources)) => {
            // ... print config info and key sources
        }
        Err(e) => {
            eprintln!("Configuration error: {}", e);
            std::process::exit(1);
        }
    }
}
```
  </action>
  <verify>
Run `cargo build` -- must compile.
Run `cargo clippy -- -D warnings` -- must pass.
Run `cargo test` -- all tests pass.
Run `cargo fmt --check` -- formatting clean.
Run `cargo run -- serve --mock` and verify it starts without errors (Ctrl-C to stop).
  </verify>
  <done>
All three commands (serve, check, providers) use from_file_with_env. Serve command logs per-provider key source at startup (ENV-04). Check command reports per-provider key availability including expected convention env var name for missing keys (ENV-05). Mock mode unchanged. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify all five ENV requirements with end-to-end checks</name>
  <files>src/main.rs</files>
  <action>
Create a temporary TOML config file and run the binary to verify all ENV success criteria end-to-end. This is a verification-only task using cargo run commands.

**ENV-01 verification (${VAR} expansion):**
1. Create /tmp/arbstr-test-env.toml with:
```toml
[server]
listen = "127.0.0.1:19876"

[[providers]]
name = "env-test"
url = "https://example.com/v1"
api_key = "${TEST_ENV_01_KEY}"
models = ["gpt-4o"]
input_rate = 10
output_rate = 30
```
2. Run: `TEST_ENV_01_KEY=cashuTestValue cargo run -- check -c /tmp/arbstr-test-env.toml`
3. Verify output contains "key from env-expanded" and "Configuration is valid"

**ENV-02 verification (missing var fails clearly):**
1. Run without setting the var: `cargo run -- check -c /tmp/arbstr-test-env.toml`
2. Verify output contains "TEST_ENV_01_KEY" (names the missing variable) and "env-test" (names the provider) and exits with error

**ENV-03 verification (convention-based auto-discovery):**
1. Create /tmp/arbstr-test-conv.toml with:
```toml
[server]
listen = "127.0.0.1:19877"

[[providers]]
name = "alpha"
url = "https://example.com/v1"
models = ["gpt-4o"]
input_rate = 10
output_rate = 30
```
(Note: no api_key field)
2. Run: `ARBSTR_ALPHA_API_KEY=cashuConvValue cargo run -- check -c /tmp/arbstr-test-conv.toml`
3. Verify output contains "key from convention" and "ARBSTR_ALPHA_API_KEY"

**ENV-04 verification (startup logs):**
1. Run: `TEST_ENV_01_KEY=cashuTestValue RUST_LOG=arbstr=info cargo run -- serve -c /tmp/arbstr-test-env.toml` (Ctrl-C after startup)
2. Verify startup logs contain "key from env-expanded" for the provider

**ENV-05 verification (check command reports):**
1. Verify the check command outputs from ENV-01 and ENV-03 above include "Provider key status:" section
2. For missing keys, verify it suggests the convention env var name

Clean up: remove /tmp/arbstr-test-env.toml and /tmp/arbstr-test-conv.toml after verification.

If any verification fails, fix the issue in src/main.rs or src/config.rs.
  </action>
  <verify>
All five ENV success criteria pass:
1. ENV-01: ${VAR} config + exported var -> starts with resolved key
2. ENV-02: ${MISSING_VAR} -> fails with clear error naming variable and provider
3. ENV-03: Omitted api_key + ARBSTR_ALPHA_API_KEY -> uses convention key
4. ENV-04: Startup logs show per-provider key source
5. ENV-05: check command reports key availability
  </verify>
  <done>
All five ENV requirements verified end-to-end via cargo run. Phase 6 success criteria fully met.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles cleanly
2. `cargo clippy -- -D warnings` passes
3. `cargo test` passes all tests
4. `cargo fmt --check` passes
5. `cargo run -- serve --mock` starts successfully
6. ENV-01 through ENV-05 all verified via cargo run with test configs
</verification>

<success_criteria>
- ENV-01 fully satisfied: ${VAR} expansion works end-to-end from config file to resolved key
- ENV-02 fully satisfied: Missing vars fail with clear error naming variable and provider
- ENV-03 fully satisfied: Convention-based auto-discovery works end-to-end
- ENV-04 fully satisfied: Startup logs show per-provider key source
- ENV-05 fully satisfied: Check command reports key availability and suggests convention var names
</success_criteria>

<output>
After completion, create `.planning/phases/06-environment-variable-expansion/06-02-SUMMARY.md`
</output>
