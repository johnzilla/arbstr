---
phase: 06-environment-variable-expansion
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/main.rs
  - tests/env_expansion.rs
autonomous: true

must_haves:
  truths:
    - "Startup logs show per-provider key source without revealing key values"
    - "cargo run -- check -c config.toml reports per-provider key availability and source"
    - "serve command uses env-var-aware config loading (from_file_with_env)"
    - "check command uses env-var-aware config loading (from_file_with_env)"
    - "providers command uses env-var-aware config loading (from_file_with_env)"
    - "Mock mode still works unchanged (no env var expansion needed)"
  artifacts:
    - path: "src/main.rs"
      provides: "Updated serve, check, providers commands using from_file_with_env"
      contains: "from_file_with_env"
  key_links:
    - from: "Commands::Serve"
      to: "Config::from_file_with_env"
      via: "calls from_file_with_env instead of from_file for real config"
      pattern: "from_file_with_env"
    - from: "Commands::Check"
      to: "Config::from_file_with_env"
      via: "calls from_file_with_env and reports key_sources"
      pattern: "from_file_with_env"
    - from: "Commands::Serve"
      to: "tracing::info"
      via: "logs KeySource per provider at startup"
      pattern: "key from"
---

<objective>
Wire the env-var-aware config loading into all CLI commands and add key source reporting at startup and in the check command.

Purpose: This completes ENV-04 (startup key source logging) and ENV-05 (check command reporting), making the expansion engine user-visible.
Output: Updated src/main.rs where serve/check/providers commands use from_file_with_env, startup logs per-provider key sources, and check command reports key availability.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-environment-variable-expansion/06-RESEARCH.md
@.planning/phases/06-environment-variable-expansion/06-01-PLAN.md
@src/main.rs
@src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update CLI commands to use env-var-aware config loading with key source reporting</name>
  <files>src/main.rs</files>
  <action>
Update src/main.rs to use Config::from_file_with_env instead of Config::from_file for all three commands. Import KeySource from config module.

**1. Update serve command (non-mock path):**

Replace `Config::from_file(&config_path)?` with:
```rust
let (config, key_sources) = Config::from_file_with_env(&config_path)?;
```

After the "Configuration loaded" tracing::info, add per-provider key source logging (ENV-04):
```rust
for (provider_name, source) in &key_sources {
    match source {
        KeySource::Literal => tracing::info!(provider = %provider_name, "key from config-literal"),
        KeySource::EnvExpanded => tracing::info!(provider = %provider_name, "key from env-expanded"),
        KeySource::Convention(var) => tracing::info!(provider = %provider_name, env_var = %var, "key from convention"),
        KeySource::None => tracing::warn!(provider = %provider_name, "no api key available"),
    }
}
```

Note: The mock path still uses `mock_config()` directly -- no key source logging needed for mock mode.

**2. Update check command (ENV-05):**

Replace `Config::from_file(&config_path)` with:
```rust
let (config, key_sources) = Config::from_file_with_env(&config_path)?;
```

After printing provider count and policy rules, add key availability reporting:
```rust
println!();
println!("Provider key status:");
for (name, source) in &key_sources {
    match source {
        KeySource::Literal => println!("  {}: key from config-literal", name),
        KeySource::EnvExpanded => println!("  {}: key from env-expanded", name),
        KeySource::Convention(var) => println!("  {}: key from convention ({})", name, var),
        KeySource::None => {
            let expected = arbstr::config::convention_env_var_name(name);
            println!("  {}: no key (set {} or add api_key to config)", name, expected);
        }
    }
}
```

For the None case, report the expected convention env var name so users know what to set. Use the public convention_env_var_name function from config.rs.

**3. Update providers command:**

Replace `Config::from_file(&config_path)?` with:
```rust
let (config, _key_sources) = Config::from_file_with_env(&config_path)?;
```

The providers command already shows provider info. No key source display needed here (Phase 7 handles masked key display).

**4. Update imports:**

Add `KeySource` to the existing `use arbstr::config::Config` import:
```rust
use arbstr::config::{Config, KeySource};
```

Also import `convention_env_var_name` if needed for the check command:
```rust
use arbstr::config::convention_env_var_name;
```
Or call it as `arbstr::config::convention_env_var_name(name)` inline.

**IMPORTANT:** Keep the mock_config() function unchanged. Mock mode bypasses file loading entirely.
**IMPORTANT:** The error handling for from_file_with_env should use `?` operator -- ConfigError already converts to anyhow::Error via the Error::Config variant, and the check command's match arm handles the error case.

For the check command specifically: the current code uses `match Config::from_file(...)` with Ok/Err arms. Update to:
```rust
Commands::Check { config: config_path } => {
    match Config::from_file_with_env(&config_path) {
        Ok((config, key_sources)) => {
            // ... print config info and key sources
        }
        Err(e) => {
            eprintln!("Configuration error: {}", e);
            std::process::exit(1);
        }
    }
}
```
  </action>
  <verify>
Run `cargo build` -- must compile.
Run `cargo clippy -- -D warnings` -- must pass.
Run `cargo test` -- all tests pass.
Run `cargo fmt --check` -- formatting clean.
Run `cargo run -- serve --mock` and verify it starts without errors (Ctrl-C to stop).
  </verify>
  <done>
All three commands (serve, check, providers) use from_file_with_env. Serve command logs per-provider key source at startup (ENV-04). Check command reports per-provider key availability including expected convention env var name for missing keys (ENV-05). Mock mode unchanged. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add automated integration tests for the full env var expansion pipeline</name>
  <files>tests/env_expansion.rs</files>
  <action>
Create `tests/env_expansion.rs` as an automated integration test file exercising the full `Config::from_file_with_env` pipeline. Use `std::fs::write` for temp configs and `std::env::set_var`/`std::env::remove_var` with unique per-test variable names. No new crate dependencies.

**Test 1: `test_env_expansion_resolves_var`** (ENV-01)
1. Set env var `TEST_E2E_06_01_KEY` to `"cashuResolved"`.
2. Write a TOML config to `/tmp/arbstr_e2e_06_01.toml`:
```toml
[server]
listen = "127.0.0.1:19876"

[[providers]]
name = "env-test"
url = "https://example.com/v1"
api_key = "${TEST_E2E_06_01_KEY}"
models = ["gpt-4o"]
input_rate = 10
output_rate = 30
```
3. Call `Config::from_file_with_env("/tmp/arbstr_e2e_06_01.toml")`.
4. Assert Ok. Find provider "env-test" and assert its api_key unwraps to "cashuResolved".
5. Assert key_sources contains ("env-test", KeySource::EnvExpanded).
6. Clean up: `std::env::remove_var("TEST_E2E_06_01_KEY")`, `std::fs::remove_file(...)`.

**Test 2: `test_env_expansion_missing_var_errors`** (ENV-02)
1. Ensure `TEST_E2E_06_02_MISSING` is NOT set (call remove_var to be safe).
2. Write TOML to `/tmp/arbstr_e2e_06_02.toml` with `api_key = "${TEST_E2E_06_02_MISSING}"` for provider "missing-test".
3. Call `Config::from_file_with_env(...)`.
4. Assert Err. Assert error display contains "TEST_E2E_06_02_MISSING" and "missing-test".
5. Clean up temp file.

**Test 3: `test_env_convention_discovers_key`** (ENV-03)
1. Set env var `ARBSTR_CONV_PROVIDER_API_KEY` to `"cashuConvention"`.
2. Write TOML to `/tmp/arbstr_e2e_06_03.toml` with provider name "conv-provider" and NO api_key field.
3. Call `Config::from_file_with_env(...)`.
4. Assert Ok. Assert provider's api_key unwraps to "cashuConvention".
5. Assert key_sources contains ("conv-provider", KeySource::Convention("ARBSTR_CONV_PROVIDER_API_KEY".into())).
6. Clean up env var and temp file.

**Test 4: `test_env_no_key_produces_none_source`**
1. Ensure `ARBSTR_NOKEY_PROVIDER_API_KEY` is NOT set.
2. Write TOML to `/tmp/arbstr_e2e_06_04.toml` with provider name "nokey-provider" and NO api_key field.
3. Call `Config::from_file_with_env(...)`.
4. Assert Ok. Assert provider's api_key is None.
5. Assert key_sources contains ("nokey-provider", KeySource::None).
6. Clean up temp file.

**Test 5: `test_env_literal_key_passthrough`**
1. Write TOML to `/tmp/arbstr_e2e_06_05.toml` with `api_key = "cashuLiteral"` for provider "literal-test".
2. Call `Config::from_file_with_env(...)`.
3. Assert Ok. Assert provider's api_key unwraps to "cashuLiteral".
4. Assert key_sources contains ("literal-test", KeySource::Literal).
5. Clean up temp file.

**Imports:** `use arbstr::config::{Config, KeySource};` and `use std::fs;`.

**IMPORTANT:** Use unique file paths per test (already shown above) to avoid parallel test interference. Each test is self-contained: creates its own temp file and cleans it up. No tempfile crate needed.
  </action>
  <verify>
Run `cargo test --test env_expansion` -- all 5 integration tests pass.
Run `cargo test` -- all tests pass (unit + integration).
Run `cargo clippy -- -D warnings` -- no warnings.
  </verify>
  <done>
5 automated integration tests in tests/env_expansion.rs covering the full from_file_with_env pipeline: env var expansion (ENV-01), missing var error (ENV-02), convention discovery (ENV-03), no-key-none-source, and literal passthrough. All tests run in CI without manual intervention. Phase 6 ENV requirements have automated regression protection.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles cleanly
2. `cargo clippy -- -D warnings` passes
3. `cargo test` passes all tests (unit + integration)
4. `cargo test --test env_expansion` passes all 5 integration tests
5. `cargo fmt --check` passes
6. `cargo run -- serve --mock` starts successfully
</verification>

<success_criteria>
- ENV-01 fully satisfied: ${VAR} expansion works end-to-end from config file to resolved key
- ENV-02 fully satisfied: Missing vars fail with clear error naming variable and provider
- ENV-03 fully satisfied: Convention-based auto-discovery works end-to-end
- ENV-04 fully satisfied: Startup logs show per-provider key source
- ENV-05 fully satisfied: Check command reports key availability and suggests convention var names
</success_criteria>

<output>
After completion, create `.planning/phases/06-environment-variable-expansion/06-02-SUMMARY.md`
</output>
