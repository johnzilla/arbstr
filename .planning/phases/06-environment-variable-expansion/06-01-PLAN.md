---
phase: 06-environment-variable-expansion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.rs
autonomous: true

must_haves:
  truths:
    - "Config with api_key = '${MY_KEY}' resolves to the value of MY_KEY env var"
    - "Config with missing ${MISSING_VAR} reference fails with error naming the variable and provider"
    - "Config with api_key omitted resolves key from ARBSTR_<UPPER_SNAKE_NAME>_API_KEY env var"
    - "Config with literal api_key still works unchanged (no regression)"
    - "Config with no api_key and no convention env var produces None key with KeySource::None"
    - "Existing parse_str tests pass without modification"
  artifacts:
    - path: "src/config.rs"
      provides: "RawProviderConfig, expand_env_vars_with, convention_key_lookup, KeySource, EnvVar error, Config::from_raw, Config::from_file_with_env"
      contains: "RawProviderConfig"
  key_links:
    - from: "Config::from_file_with_env"
      to: "Config::from_raw"
      via: "parses TOML into RawConfig then converts"
      pattern: "from_raw"
    - from: "Config::from_raw"
      to: "expand_env_vars_with"
      via: "expands ${VAR} in raw api_key strings"
      pattern: "expand_env_vars"
    - from: "Config::from_raw"
      to: "convention_key_lookup"
      via: "auto-discovers key from env when api_key is None"
      pattern: "convention_key_lookup"
---

<objective>
Implement the core environment variable expansion engine: RawProviderConfig for two-phase config loading, `${VAR}` expansion with closure-based lookup for testability, convention-based auto-discovery (`ARBSTR_<NAME>_API_KEY`), KeySource tracking, and comprehensive unit tests.

Purpose: This is the foundation for all five ENV requirements. Without the expansion engine, no env var features work.
Output: Updated src/config.rs with RawProviderConfig, expand_env_vars_with, convention_key_lookup, KeySource enum, EnvVar error variant, Config::from_raw, Config::from_file_with_env, and 10+ unit tests.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-environment-variable-expansion/06-RESEARCH.md
@.planning/phases/05-secret-type-foundation/05-01-SUMMARY.md
@src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RawProviderConfig, env expansion engine, convention lookup, and KeySource</name>
  <files>src/config.rs</files>
  <action>
Add the following to src/config.rs, keeping all existing types and methods intact:

1. **KeySource enum** (public, above Config):
```rust
#[derive(Debug, Clone, PartialEq)]
pub enum KeySource {
    Literal,
    EnvExpanded,
    Convention(String),  // holds env var name
    None,
}
```
Add `impl std::fmt::Display for KeySource` with format strings: "config-literal", "env-expanded", "convention ({var})", "none".

2. **EnvVar error variant** on ConfigError:
```rust
#[error("Environment variable '{var}' not set for provider '{provider}': {message}")]
EnvVar {
    var: String,
    provider: String,
    message: String,
},
```

3. **RawProviderConfig struct** (private, does NOT need Debug/Clone):
```rust
#[derive(Deserialize)]
struct RawProviderConfig {
    name: String,
    url: String,
    api_key: Option<String>,  // raw, may contain ${VAR}
    #[serde(default)]
    models: Vec<String>,
    #[serde(default)]
    input_rate: u64,
    #[serde(default)]
    output_rate: u64,
    #[serde(default)]
    base_fee: u64,
}
```

4. **RawConfig struct** (private):
```rust
#[derive(Deserialize)]
struct RawConfig {
    server: ServerConfig,
    database: Option<DatabaseConfig>,
    #[serde(default)]
    providers: Vec<RawProviderConfig>,
    #[serde(default)]
    policies: PoliciesConfig,
    #[serde(default)]
    logging: LoggingConfig,
}
```
Note: ServerConfig, DatabaseConfig, PoliciesConfig, LoggingConfig are reused directly (no secret fields).

5. **expand_env_vars_with function** (private, closure-based for testability):
```rust
fn expand_env_vars_with<F>(input: &str, provider_name: &str, lookup: F) -> Result<String, ConfigError>
where F: Fn(&str) -> Option<String>
```
Implementation per research: find("${"), find("}"), extract var name, call lookup. Handle edge cases:
- Early return if no "${" found (return Ok(input.to_string()))
- Error on unclosed "${" (ConfigError::EnvVar with var="<unclosed>")
- Error on empty var name "${}" (ConfigError::EnvVar with descriptive message)
- Error on missing var (ConfigError::EnvVar naming var and provider)
- Support multiple ${VAR} in one string

6. **expand_env_vars convenience wrapper** (private):
```rust
fn expand_env_vars(input: &str, provider_name: &str) -> Result<String, ConfigError> {
    expand_env_vars_with(input, provider_name, |name| std::env::var(name).ok())
}
```

7. **convention_env_var_name function** (public, for check command to report expected names):
```rust
pub fn convention_env_var_name(provider_name: &str) -> String
```
Transform: uppercase, replace hyphens and spaces with underscores, wrap with ARBSTR_ prefix and _API_KEY suffix.

8. **convention_key_lookup function** (private):
```rust
fn convention_key_lookup(provider_name: &str) -> Option<(String, String)>
```
Returns Some((var_name, value)) if ARBSTR_<NAME>_API_KEY is set.

9. **Config::from_raw method** (public, returns key sources alongside config):
```rust
pub fn from_raw(raw: RawConfig) -> Result<(Self, Vec<(String, KeySource)>), ConfigError>
```
For each RawProviderConfig:
- If api_key is Some and contains "${": expand_env_vars, wrap in ApiKey, source = EnvExpanded
- If api_key is Some without "${": wrap in ApiKey, source = Literal
- If api_key is None: try convention_key_lookup. If found: wrap, source = Convention(var_name). If not: None key, source = KeySource::None

10. **Config::from_file_with_env method** (public):
```rust
pub fn from_file_with_env(path: impl AsRef<Path>) -> Result<(Self, Vec<(String, KeySource)>), ConfigError>
```
Reads file, parses as RawConfig via toml::from_str, calls from_raw, calls validate on result.

**IMPORTANT:** Do NOT modify `Config::parse_str` or `Config::from_file`. Keep them as-is for backward compatibility. Existing tests use parse_str with literal keys and must not break. The new from_file_with_env is a separate entry point.

**IMPORTANT:** Do NOT log key sources in this plan. Logging happens in Plan 02 when main.rs is updated. Config module should be pure data transformation.
  </action>
  <verify>
Run `cargo build` -- must compile with no errors.
Run `cargo clippy -- -D warnings` -- must pass with no warnings.
Run `cargo test` -- all existing tests must pass (no regressions).
  </verify>
  <done>
RawProviderConfig, RawConfig, expand_env_vars_with, convention_key_lookup, convention_env_var_name, KeySource, EnvVar error, Config::from_raw, Config::from_file_with_env all exist in src/config.rs. Existing parse_str and from_file methods unchanged. Compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive unit tests for env var expansion engine</name>
  <files>src/config.rs</files>
  <action>
Add unit tests to the existing `mod tests` block in src/config.rs. Use the closure-based `expand_env_vars_with` for all expansion tests (no global env state, no test interference).

**Expansion tests (using expand_env_vars_with):**

1. `test_expand_single_var` -- "${MY_KEY}" with MY_KEY="cashuABCD" -> "cashuABCD"
2. `test_expand_multiple_vars` -- "${SCHEME}://${HOST}/v1" with both set -> "https://example.com/v1"
3. `test_expand_no_vars_passthrough` -- "literal-value" (lookup should NOT be called, use panic in lookup to verify)
4. `test_expand_mixed_literal_and_var` -- "prefix-${KEY}-suffix" -> "prefix-resolved-suffix"
5. `test_expand_missing_var_fails` -- "${MISSING}" with empty lookup -> Err containing "MISSING" and provider name
6. `test_expand_unclosed_brace_fails` -- "${UNCLOSED" -> Err containing "unclosed" (case-insensitive check)
7. `test_expand_empty_var_name_fails` -- "${}" -> Err containing descriptive message
8. `test_expand_dollar_without_brace_passthrough` -- "$NOT_A_VAR" -> "$NOT_A_VAR" (only ${} syntax recognized)

**Convention tests:**

9. `test_convention_env_var_name_simple` -- "alpha" -> "ARBSTR_ALPHA_API_KEY"
10. `test_convention_env_var_name_hyphen` -- "provider-beta" -> "ARBSTR_PROVIDER_BETA_API_KEY"
11. `test_convention_env_var_name_underscore` -- "my_service" -> "ARBSTR_MY_SERVICE_API_KEY"

**from_raw integration tests (using std::env::set_var/remove_var with unique var names per test):**

12. `test_from_raw_literal_key` -- RawConfig with api_key = Some("literal") -> source = Literal, key = "literal"
13. `test_from_raw_env_expanded_key` -- Set unique env var, RawConfig with api_key = Some("${TEST_06_EXPAND_KEY}") -> source = EnvExpanded, key = env value. Clean up env var after.
14. `test_from_raw_convention_key` -- Set ARBSTR_ALPHA_API_KEY env var with unique name, RawConfig with api_key = None, provider name = test-unique name matching the env var. Verify source = Convention. Clean up after.
15. `test_from_raw_no_key` -- RawConfig with api_key = None, no convention env var set -> source = KeySource::None, key = None
16. `test_from_raw_missing_env_var_fails` -- RawConfig with api_key = Some("${TEST_06_DEFINITELY_MISSING}") -> Err containing var name and provider name

For tests 12-16 that build RawConfig, construct them programmatically:
```rust
let raw = RawConfig {
    server: ServerConfig { listen: "127.0.0.1:9000".to_string() },
    database: None,
    providers: vec![RawProviderConfig { ... }],
    policies: PoliciesConfig::default(),
    logging: LoggingConfig::default(),
};
```

**IMPORTANT:** Use unique env var names for each test to avoid parallel test interference (e.g., TEST_06_01_KEY, TEST_06_02_KEY). Always clean up with std::env::remove_var in the test body (not relying on drop guards).
  </action>
  <verify>
Run `cargo test` -- all tests pass including new ones.
Run `cargo test -- test_expand` -- expansion tests pass.
Run `cargo test -- test_convention` -- convention tests pass.
Run `cargo test -- test_from_raw` -- integration tests pass.
Run `cargo clippy -- -D warnings` -- no warnings.
  </verify>
  <done>
16 new unit tests covering: single/multiple/mixed var expansion, passthrough for non-var strings, error cases (missing var, unclosed brace, empty name, dollar without brace), convention name transformation, and full from_raw integration for all four key sources (literal, env-expanded, convention, none) plus missing-var error path. All tests pass alongside existing tests.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` compiles cleanly
2. `cargo clippy -- -D warnings` passes
3. `cargo test` passes all tests (existing + new)
4. `cargo fmt --check` passes
5. Verify KeySource, convention_env_var_name, from_file_with_env are public (needed by Plan 02)
6. Verify parse_str and from_file still work unchanged (backward compatibility)
</verification>

<success_criteria>
- ENV-01 partially satisfied: ${VAR} expansion works at the config.rs level (full path through main.rs in Plan 02)
- ENV-02 satisfied: Missing env var causes clear error naming variable and provider
- ENV-03 partially satisfied: Convention lookup works at the config.rs level (full path through main.rs in Plan 02)
- All existing tests pass with no modifications
- 16+ new unit tests covering expansion, convention, and integration paths
</success_criteria>

<output>
After completion, create `.planning/phases/06-environment-variable-expansion/06-01-SUMMARY.md`
</output>
