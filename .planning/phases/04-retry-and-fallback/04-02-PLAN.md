---
phase: 04-retry-and-fallback
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/proxy/retry.rs
  - src/proxy/mod.rs
autonomous: true

must_haves:
  truths:
    - "A retryable 5xx error triggers up to 2 retries with 1s, 2s backoff delays"
    - "A non-retryable 4xx error fails immediately without retry"
    - "After primary retries exhaust, a single fallback attempt is made on the next candidate"
    - "Fallback provider gets one shot only, no retries"
    - "If no fallback candidate exists, the last primary error is returned"
    - "Attempt history is tracked via shared Arc<Mutex<Vec<AttemptRecord>>> and can be formatted as x-arbstr-retries header"
    - "Attempt history survives timeout cancellation because it is recorded externally"
  artifacts:
    - path: "src/proxy/retry.rs"
      provides: "retry_with_fallback(), AttemptRecord, RetryOutcome, format_retries_header(), is_retryable()"
      contains: "pub async fn retry_with_fallback"
      min_lines: 80
    - path: "src/proxy/mod.rs"
      provides: "pub mod retry declaration"
      contains: "pub mod retry"
  key_links:
    - from: "retry_with_fallback"
      to: "is_retryable"
      via: "checks status code to decide retry vs fail"
      pattern: "is_retryable"
    - from: "retry_with_fallback"
      to: "tokio::time::sleep"
      via: "backoff delay before each retry attempt"
      pattern: "sleep\\(BACKOFF"
    - from: "retry_with_fallback"
      to: "Arc<Mutex<Vec<AttemptRecord>>>"
      via: "records attempts to shared vec that survives timeout cancellation"
      pattern: "Arc<Mutex<Vec<AttemptRecord>>>"
---

<objective>
Create the retry module with the core retry-with-fallback logic, attempt tracking types, and header formatting. This module is self-contained and testable in isolation.

Purpose: Encapsulate all retry/fallback logic in a dedicated module so the handler integration (Plan 03) is a clean wiring task.
Output: `src/proxy/retry.rs` with `retry_with_fallback()`, types, unit tests.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-retry-and-fallback/04-CONTEXT.md
@.planning/phases/04-retry-and-fallback/04-RESEARCH.md
@src/proxy/mod.rs
@src/proxy/handlers.rs
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create retry module with core types and functions</name>
  <files>src/proxy/retry.rs, src/proxy/mod.rs</files>
  <action>
Create `src/proxy/retry.rs` with the following:

**Constants:**
```rust
use std::time::Duration;

const BACKOFF_DURATIONS: [Duration; 3] = [
    Duration::from_secs(1),
    Duration::from_secs(2),
    Duration::from_secs(4),
];
const MAX_RETRIES: u32 = 2;
```
The full [1s, 2s, 4s] sequence matches the locked decision "Fixed exponential backoff: 1s, 2s, 4s" from CONTEXT.md. With MAX_RETRIES=2, the code indexes with `attempt - 1` (0 and 1), so only the 1s and 2s slots are used at runtime. The 4s entry documents the full sequence and would be used if MAX_RETRIES were increased.

**Types:**

```rust
use std::sync::{Arc, Mutex};

/// Record of a single failed attempt for building x-arbstr-retries header.
#[derive(Debug, Clone)]
pub struct AttemptRecord {
    pub provider_name: String,
    pub status_code: u16,
}

/// Outcome of the full retry+fallback sequence.
pub struct RetryOutcome<T, E> {
    pub result: std::result::Result<T, E>,
}
```

Make `RetryOutcome` generic over `T` (success type) and `E` (error type) so it can be tested without depending on `RequestOutcome`/`RequestError` directly. The handler integration will use `RetryOutcome<RequestOutcome, RequestError>`.

Note: `RetryOutcome` does NOT contain an `attempts` field. Attempts are tracked via the shared `Arc<Mutex<Vec<AttemptRecord>>>` parameter passed into `retry_with_fallback`. This design ensures attempt history survives timeout cancellation -- the caller creates the Arc before calling `timeout_at`, and reads it after timeout to retrieve whatever was recorded before cancellation.

**Functions:**

1. `is_retryable(status_code: u16) -> bool` -- Returns true for 500, 502, 503, 504. Public for testability.

2. `format_retries_header(attempts: &[AttemptRecord]) -> Option<String>` -- Builds "2/provider-alpha, 1/provider-beta" format. Returns None if attempts is empty. Groups by provider name preserving first-appearance order.

3. `retry_with_fallback` -- The core async function. Use a generic approach with a closure/async function parameter to keep it testable without needing real HTTP:

```rust
pub async fn retry_with_fallback<T, E, F, Fut>(
    candidates: &[CandidateInfo],
    attempts: Arc<Mutex<Vec<AttemptRecord>>>,
    send_request: F,
) -> RetryOutcome<T, E>
where
    E: HasStatusCode,
    F: Fn(&CandidateInfo) -> Fut,
    Fut: std::future::Future<Output = std::result::Result<T, E>>,
```

The `attempts` parameter is an `Arc<Mutex<Vec<AttemptRecord>>>` that the caller creates and owns. The function pushes each failed attempt record into this shared vec. This design allows the caller (in Plan 03) to create the Arc before `timeout_at` and read the accumulated attempts even if the retry future is cancelled by timeout.

Where `CandidateInfo` is a lightweight struct with just the info retry needs:
```rust
#[derive(Debug, Clone)]
pub struct CandidateInfo {
    pub name: String,
}
```

And `HasStatusCode` is a trait so the retry module can inspect error status codes without depending on `RequestError`:
```rust
pub trait HasStatusCode {
    fn status_code(&self) -> u16;
}
```

**Algorithm:**
1. Take first candidate as primary, second (if exists) as fallback
2. Attempt primary up to `MAX_RETRIES + 1` times (3 total)
3. On success: return immediately (attempt history already recorded in shared vec)
4. On error: push `AttemptRecord { provider_name, status_code }` into the shared `attempts` vec via `attempts.lock().unwrap().push(...)`
5. If `is_retryable(err.status_code())` and attempts remaining, sleep for `BACKOFF_DURATIONS[attempt-1]` then retry
6. On non-retryable error: return immediately (no more retries, no fallback)
7. After primary exhausted with retryable errors: try fallback once (if exists)
8. If no fallback exists: return last primary error

Key details:
- Sleep happens BEFORE the next attempt, not after the failure (avoids sleeping after final failure)
- Only record FAILED attempts in the shared attempts vec (successful attempt is the result)
- Non-retryable errors skip fallback entirely -- 4xx from primary means fail fast
- The Mutex lock is held only briefly for the push operation, then immediately released

**In `src/proxy/mod.rs`:** Add `pub mod retry;` to the module declarations.

**Unit tests** in `#[cfg(test)] mod tests` within retry.rs:

For testing, create a mock error type:
```rust
#[cfg(test)]
struct MockError { code: u16 }
impl HasStatusCode for MockError { fn status_code(&self) -> u16 { self.code } }
```

Use `std::sync::atomic::AtomicU32` to track call counts in test closures. Use `tokio::test` for async tests.

Each test creates its own `Arc<Mutex<Vec<AttemptRecord>>>` and passes it to `retry_with_fallback`, then inspects the vec after the call returns to verify attempt history. Example pattern:
```rust
let attempts = Arc::new(Mutex::new(Vec::new()));
let outcome = retry_with_fallback(&candidates, attempts.clone(), |info| async { ... }).await;
let recorded = attempts.lock().unwrap();
assert_eq!(recorded.len(), expected_count);
```

Tests:
1. `test_is_retryable` -- 500,502,503,504 are retryable; 400,401,403,404,429 are not
2. `test_format_retries_header_empty` -- empty vec returns None
3. `test_format_retries_header_single_provider` -- 2 attempts on "alpha" -> "2/alpha"
4. `test_format_retries_header_multiple_providers` -- 2 on "alpha" + 1 on "beta" -> "2/alpha, 1/beta"
5. `test_success_on_first_attempt` -- no retries, attempts vec empty
6. `test_retry_then_success` -- first attempt 503, second succeeds. Verify 1 attempt in shared vec, send_request called twice
7. `test_max_retries_exhausted_no_fallback` -- 3 failures (all 503), 1 candidate. Returns error, 3 attempts in shared vec
8. `test_max_retries_then_fallback_success` -- 3 primary failures (503), fallback succeeds. 3 attempts in shared vec (primary only)
9. `test_max_retries_then_fallback_failure` -- 3 primary + 1 fallback failures. 4 attempts in shared vec
10. `test_non_retryable_fails_immediately` -- 400 error, only 1 attempt in shared vec, no retry, no fallback
11. `test_backoff_delays` -- Use `tokio::time::pause()` + `tokio::time::resume()` to verify that retries wait 1s and 2s. With `tokio::time::pause()`, time is virtual and tests run instantly while still verifying sleep durations. After first failure, advance to show 1s elapsed; after second failure, advance to show 2s elapsed.

Important: For async tests with sleep verification, use `#[tokio::test(start_paused = true)]` so `tokio::time::sleep` completes instantly but `tokio::time::Instant` still tracks elapsed virtual time.
  </action>
  <verify>
Run `cargo test --lib proxy::retry` -- all tests pass.
Run `cargo clippy -- -D warnings` -- no warnings.
Run `cargo build` -- compiles.
  </verify>
  <done>
`src/proxy/retry.rs` exists with `retry_with_fallback()` accepting `Arc<Mutex<Vec<AttemptRecord>>>`, `AttemptRecord`, `RetryOutcome`, `CandidateInfo`, `HasStatusCode`, `is_retryable()`, `format_retries_header()`. `BACKOFF_DURATIONS` is `[Duration; 3] = [1s, 2s, 4s]` matching the locked decision. All 11 unit tests pass. Module declared in `src/proxy/mod.rs`.
  </done>
</task>

</tasks>

<verification>
- `cargo test` -- all tests pass
- `cargo clippy -- -D warnings` -- clean
- `cargo build` -- compiles
</verification>

<success_criteria>
- `BACKOFF_DURATIONS` is `[Duration; 3] = [1s, 2s, 4s]` matching locked decision from CONTEXT.md
- `retry_with_fallback` accepts `Arc<Mutex<Vec<AttemptRecord>>>` for shared attempt tracking that survives timeout
- `retry_with_fallback` retries up to 2 times on 5xx with 1s, 2s backoff
- Non-retryable errors (4xx) fail immediately without retry or fallback
- After primary exhausted, one fallback attempt on second candidate
- `format_retries_header` produces "2/alpha, 1/beta" format
- All 11 unit tests pass covering happy path, retries, fallback, non-retryable, backoff timing
- Module is generic and does not depend on handler types
</success_criteria>

<output>
After completion, create `.planning/phases/04-retry-and-fallback/04-02-SUMMARY.md`
</output>
