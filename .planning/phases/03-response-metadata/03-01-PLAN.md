---
phase: 03-response-metadata
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/proxy/handlers.rs]
autonomous: true

must_haves:
  truths:
    - "Non-streaming success responses include x-arbstr-request-id, x-arbstr-cost-sats, x-arbstr-latency-ms, and x-arbstr-provider headers"
    - "Streaming success responses include x-arbstr-request-id, x-arbstr-provider, and x-arbstr-streaming headers but NOT x-arbstr-cost-sats or x-arbstr-latency-ms"
    - "Error responses include x-arbstr-request-id and x-arbstr-latency-ms headers, plus x-arbstr-provider when known"
    - "Headers are visible to standard HTTP clients (curl -v) without special configuration"
    - "No duplicate x-arbstr-provider header on any response"
  artifacts:
    - path: "src/proxy/handlers.rs"
      provides: "Header constants, attach_arbstr_headers helper, restructured chat_completions response paths"
      contains: "ARBSTR_REQUEST_ID_HEADER"
  key_links:
    - from: "chat_completions match Ok arm"
      to: "attach_arbstr_headers"
      via: "function call with outcome metadata"
      pattern: "attach_arbstr_headers.*&mut.*response"
    - from: "chat_completions match Err arm"
      to: "attach_arbstr_headers"
      via: "function call with error metadata"
      pattern: "attach_arbstr_headers.*error_response"
    - from: "attach_arbstr_headers"
      to: "response headers"
      via: "headers_mut().insert()"
      pattern: "headers\\.insert"
---

<objective>
Add response metadata headers to all chat completion responses (success, streaming, and error paths).

Purpose: Clients need per-request cost, latency, provider, and correlation ID visible in HTTP headers for debugging and cost tracking without parsing response bodies.

Output: Modified `src/proxy/handlers.rs` with header constants, `attach_arbstr_headers` helper function, centralized header attachment on all response paths, removed duplicate `x-arbstr-provider` from sub-handlers, and unit tests for the helper function.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-response-metadata/03-RESEARCH.md
@.planning/phases/03-response-metadata/03-CONTEXT.md
@.planning/phases/02-request-logging/02-04-SUMMARY.md
@src/proxy/handlers.rs
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add header constants, helper function, and restructure response paths</name>
  <files>src/proxy/handlers.rs</files>
  <action>
Make the following changes to `src/proxy/handlers.rs`:

**1. Add header constant declarations** after the existing `ARBSTR_POLICY_HEADER` constant (line 18):

```rust
/// Response header: correlation ID (UUID v4).
pub const ARBSTR_REQUEST_ID_HEADER: &str = "x-arbstr-request-id";
/// Response header: actual cost in satoshis (decimal, e.g. "42.35").
pub const ARBSTR_COST_SATS_HEADER: &str = "x-arbstr-cost-sats";
/// Response header: wall-clock latency in milliseconds (integer).
pub const ARBSTR_LATENCY_MS_HEADER: &str = "x-arbstr-latency-ms";
/// Response header: provider name that handled the request.
pub const ARBSTR_PROVIDER_HEADER: &str = "x-arbstr-provider";
/// Response header: present with value "true" on streaming responses.
pub const ARBSTR_STREAMING_HEADER: &str = "x-arbstr-streaming";
```

**2. Add `attach_arbstr_headers` helper function** (place it after `extract_usage`, before `chat_completions`):

```rust
/// Attach arbstr metadata headers to a response.
///
/// For non-streaming responses: sets request-id, latency, provider, and cost.
/// For streaming responses: sets request-id, provider, and streaming flag.
/// Cost and latency are omitted on streaming responses (not known at header-send time).
fn attach_arbstr_headers(
    response: &mut Response,
    request_id: &str,
    latency_ms: i64,
    provider: Option<&str>,
    cost_sats: Option<f64>,
    is_streaming: bool,
) {
    let headers = response.headers_mut();

    // Always present
    headers.insert(
        HeaderName::from_static(ARBSTR_REQUEST_ID_HEADER),
        HeaderValue::from_str(request_id).unwrap(),
    );

    if is_streaming {
        headers.insert(
            HeaderName::from_static(ARBSTR_STREAMING_HEADER),
            HeaderValue::from_static("true"),
        );
        // Streaming: omit cost and latency (not known at header-send time)
    } else {
        // Non-streaming: always include latency
        headers.insert(
            HeaderName::from_static(ARBSTR_LATENCY_MS_HEADER),
            HeaderValue::from(latency_ms as u64),
        );
        // Non-streaming: include cost if known
        if let Some(cost) = cost_sats {
            headers.insert(
                HeaderName::from_static(ARBSTR_COST_SATS_HEADER),
                HeaderValue::from_str(&format!("{:.2}", cost)).unwrap(),
            );
        }
    }

    // Provider: present when known
    if let Some(provider_name) = provider {
        headers.insert(
            HeaderName::from_static(ARBSTR_PROVIDER_HEADER),
            HeaderValue::from_str(provider_name).unwrap(),
        );
    }
}
```

Add `HeaderName` and `HeaderValue` to the axum::http import at the top of the file. The existing import is:
```rust
use axum::http::{header, HeaderMap, StatusCode};
```
Change to:
```rust
use axum::http::{header, HeaderMap, HeaderName, HeaderValue, StatusCode};
```

**3. Remove duplicate `x-arbstr-provider` header** from both response builders:

In `handle_non_streaming_response`, remove `.header("x-arbstr-provider", &provider.name)` from the `Response::builder()` chain (around line 280).

In `handle_streaming_response`, remove `.header("x-arbstr-provider", &provider_name)` from the `Response::builder()` chain (around line 356).

**4. Restructure the `chat_completions` return** (the match at the end of the function, around lines 126-130):

Change from:
```rust
match result {
    Ok(outcome) => Ok(outcome.response),
    Err(outcome_err) => Err(outcome_err.error),
}
```

To:
```rust
match result {
    Ok(outcome) => {
        let mut response = outcome.response;
        attach_arbstr_headers(
            &mut response,
            &correlation_id,
            latency_ms,
            Some(&outcome.provider_name),
            outcome.cost_sats,
            is_streaming,
        );
        Ok(response)
    }
    Err(outcome_err) => {
        let mut error_response = outcome_err.error.into_response();
        attach_arbstr_headers(
            &mut error_response,
            &correlation_id,
            latency_ms,
            outcome_err.provider_name.as_deref(),
            None, // cost not known for errors
            is_streaming,
        );
        Ok(error_response)
    }
}
```

NOTE: The error path now returns `Ok(error_response)` instead of `Err(...)`. The handler return type stays `Result<Response, Error>` but the error path within `chat_completions` always returns `Ok` with the error body + arbstr headers. Pre-handler errors (JSON parse failures from axum's `Json` extractor) still produce error responses without arbstr headers -- this is expected and acceptable.
  </action>
  <verify>
Run `cargo build` -- must compile cleanly.
Run `cargo clippy -- -D warnings` -- no warnings.
Run `cargo test` -- all existing tests pass.
Grep for duplicate provider header: `grep -n 'x-arbstr-provider' src/proxy/handlers.rs` should show only the constant declaration and the helper function, NOT in Response::builder() chains.
  </verify>
  <done>
- All 6 header constants are defined
- `attach_arbstr_headers` helper exists and handles streaming/non-streaming/error cases
- `chat_completions` attaches headers on both Ok and Err paths
- No duplicate `x-arbstr-provider` in response builders
- Compilation and clippy clean
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for attach_arbstr_headers</name>
  <files>src/proxy/handlers.rs</files>
  <action>
Add the following tests to the existing `#[cfg(test)] mod tests` block in `src/proxy/handlers.rs`:

**Test 1: Non-streaming response gets all headers**
```rust
#[test]
fn test_attach_headers_non_streaming() {
    let mut response = Response::builder()
        .status(StatusCode::OK)
        .body(Body::empty())
        .unwrap();
    attach_arbstr_headers(
        &mut response,
        "550e8400-e29b-41d4-a716-446655440000",
        1523,
        Some("provider-alpha"),
        Some(42.35),
        false,
    );
    let headers = response.headers();
    assert_eq!(
        headers.get("x-arbstr-request-id").unwrap(),
        "550e8400-e29b-41d4-a716-446655440000"
    );
    assert_eq!(headers.get("x-arbstr-latency-ms").unwrap(), "1523");
    assert_eq!(headers.get("x-arbstr-cost-sats").unwrap(), "42.35");
    assert_eq!(headers.get("x-arbstr-provider").unwrap(), "provider-alpha");
    assert!(headers.get("x-arbstr-streaming").is_none());
}
```

**Test 2: Streaming response gets partial headers**
```rust
#[test]
fn test_attach_headers_streaming() {
    let mut response = Response::builder()
        .status(StatusCode::OK)
        .body(Body::empty())
        .unwrap();
    attach_arbstr_headers(
        &mut response,
        "550e8400-e29b-41d4-a716-446655440000",
        500,
        Some("provider-beta"),
        Some(10.00),  // cost provided but should be ignored for streaming
        true,
    );
    let headers = response.headers();
    assert_eq!(
        headers.get("x-arbstr-request-id").unwrap(),
        "550e8400-e29b-41d4-a716-446655440000"
    );
    assert_eq!(headers.get("x-arbstr-streaming").unwrap(), "true");
    assert_eq!(headers.get("x-arbstr-provider").unwrap(), "provider-beta");
    // Streaming omits cost and latency
    assert!(headers.get("x-arbstr-cost-sats").is_none());
    assert!(headers.get("x-arbstr-latency-ms").is_none());
}
```

**Test 3: Error response (no provider, no cost)**
```rust
#[test]
fn test_attach_headers_error_no_provider() {
    let mut response = Response::builder()
        .status(StatusCode::BAD_REQUEST)
        .body(Body::empty())
        .unwrap();
    attach_arbstr_headers(
        &mut response,
        "abcd1234-0000-0000-0000-000000000000",
        50,
        None,   // no provider (pre-route error)
        None,   // no cost
        false,
    );
    let headers = response.headers();
    assert_eq!(
        headers.get("x-arbstr-request-id").unwrap(),
        "abcd1234-0000-0000-0000-000000000000"
    );
    assert_eq!(headers.get("x-arbstr-latency-ms").unwrap(), "50");
    assert!(headers.get("x-arbstr-provider").is_none());
    assert!(headers.get("x-arbstr-cost-sats").is_none());
    assert!(headers.get("x-arbstr-streaming").is_none());
}
```

**Test 4: Non-streaming with no cost (usage extraction failed)**
```rust
#[test]
fn test_attach_headers_no_cost() {
    let mut response = Response::builder()
        .status(StatusCode::OK)
        .body(Body::empty())
        .unwrap();
    attach_arbstr_headers(
        &mut response,
        "11111111-2222-3333-4444-555555555555",
        200,
        Some("provider-gamma"),
        None,  // cost unknown
        false,
    );
    let headers = response.headers();
    assert_eq!(
        headers.get("x-arbstr-request-id").unwrap(),
        "11111111-2222-3333-4444-555555555555"
    );
    assert_eq!(headers.get("x-arbstr-latency-ms").unwrap(), "200");
    assert_eq!(headers.get("x-arbstr-provider").unwrap(), "provider-gamma");
    assert!(headers.get("x-arbstr-cost-sats").is_none());
}
```

**Test 5: Cost formatting precision**
```rust
#[test]
fn test_attach_headers_cost_formatting() {
    let mut response = Response::builder()
        .status(StatusCode::OK)
        .body(Body::empty())
        .unwrap();
    attach_arbstr_headers(
        &mut response,
        "00000000-0000-0000-0000-000000000000",
        100,
        Some("provider"),
        Some(0.10),  // should format as "0.10" not "0.1"
        false,
    );
    assert_eq!(
        response.headers().get("x-arbstr-cost-sats").unwrap(),
        "0.10"
    );
}
```
  </action>
  <verify>
Run `cargo test` -- all tests pass including the 5 new ones.
Run `cargo test -- test_attach_headers` -- 5 tests match and pass.
  </verify>
  <done>
- 5 unit tests covering: non-streaming (full headers), streaming (partial headers), error (no provider), no cost, cost formatting precision
- All tests pass
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `cargo build` -- compiles cleanly
2. `cargo clippy -- -D warnings` -- no warnings
3. `cargo test` -- all tests pass (existing + 5 new)
4. `grep -c 'x-arbstr-provider' src/proxy/handlers.rs` -- constant + helper only, not in Response::builder chains
5. `grep 'ARBSTR_.*HEADER' src/proxy/handlers.rs` -- all 6 constants present (POLICY, REQUEST_ID, COST_SATS, LATENCY_MS, PROVIDER, STREAMING)
6. Manual smoke test (optional): `cargo run -- serve --mock` then `curl -s -D - http://localhost:8080/v1/chat/completions -H "Content-Type: application/json" -d '{"model":"gpt-4o","messages":[{"role":"user","content":"hi"}]}'` -- response headers include x-arbstr-request-id, x-arbstr-cost-sats, x-arbstr-latency-ms, x-arbstr-provider
</verification>

<success_criteria>
- Non-streaming responses include x-arbstr-request-id, x-arbstr-cost-sats, x-arbstr-latency-ms, and x-arbstr-provider headers
- Streaming responses include x-arbstr-request-id, x-arbstr-provider, and x-arbstr-streaming: true -- but NOT cost or latency
- Error responses include x-arbstr-request-id and x-arbstr-latency-ms -- plus x-arbstr-provider when the provider was known
- No duplicate x-arbstr-provider header on any response path
- Cost formatted as decimal with 2 decimal places (e.g. "42.35", "0.10")
- Latency formatted as integer milliseconds
- All existing tests pass, 5 new tests pass
- cargo clippy clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-response-metadata/03-01-SUMMARY.md`
</output>
