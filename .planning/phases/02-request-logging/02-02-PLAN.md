---
phase: 02-request-logging
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib.rs
  - src/error.rs
  - src/proxy/server.rs
autonomous: true

must_haves:
  truths:
    - "Storage module is accessible from other crates and modules via lib.rs"
    - "Database errors during pool initialization propagate as typed Error::Database"
    - "Server starts with an SQLite pool available to handlers via AppState"
    - "Server continues to function if database initialization fails (logging disabled gracefully)"
    - "cargo build succeeds and all existing tests pass with no regressions"
  artifacts:
    - path: "src/lib.rs"
      provides: "Storage module registration"
      contains: "pub mod storage"
    - path: "src/error.rs"
      provides: "Database error variant"
      contains: "Database"
    - path: "src/proxy/server.rs"
      provides: "AppState with db field, pool initialization in run_server"
      contains: "init_pool"
  key_links:
    - from: "AppState"
      to: "SqlitePool"
      via: "Option<SqlitePool> field named db"
      pattern: "db.*Option.*SqlitePool|Option.*SqlitePool.*db"
    - from: "run_server"
      to: "init_pool"
      via: "Pool created during server startup"
      pattern: "init_pool"
    - from: "Error"
      to: "sqlx::Error"
      via: "Database variant"
      pattern: "Database"
---

<objective>
Integrate the storage module into the server: register in lib.rs, add Database error variant, and wire SqlitePool into AppState.

Purpose: Plan 02-01 created the storage module in isolation. This plan wires it into the rest of the codebase so handlers can access the database pool. After this plan, the pool is initialized on startup and available in AppState for handler use in plan 02-04.

Output: Storage module registered, Error::Database variant added, AppState has db field, pool initialized in run_server.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-request-logging/02-CONTEXT.md
@.planning/phases/02-request-logging/02-01-SUMMARY.md
@src/lib.rs
@src/error.rs
@src/proxy/server.rs
@src/proxy/mod.rs
@src/config.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register storage module and add Database error variant</name>
  <files>src/lib.rs, src/error.rs</files>
  <action>
    1. Add the storage module to `src/lib.rs`:

       Add `pub mod storage;` after the existing module declarations. The file should look like:

       ```rust
       //! arbstr - Intelligent LLM routing and cost arbitrage for Routstr
       //!
       //! This library provides the core functionality for the arbstr proxy,
       //! including configuration, routing, and provider management.

       pub mod config;
       pub mod error;
       pub mod proxy;
       pub mod router;
       pub mod storage;

       pub use config::Config;
       pub use error::{Error, Result};
       ```

    2. Add a `Database` variant to the `Error` enum in `src/error.rs` for database errors during pool initialization:

       Add the variant to the enum:
       ```rust
       #[error("Database error: {0}")]
       Database(#[from] sqlx::Error),
       ```

       Add the match arm in `IntoResponse`:
       ```rust
       Error::Database(_) => (StatusCode::INTERNAL_SERVER_ERROR, self.to_string()),
       ```

       This variant is needed because pool initialization errors in `run_server()` must propagate as typed errors. Write-path errors in fire-and-forget are logged as warnings (don't need this variant), but having it available is good for future query endpoints.
  </action>
  <verify>
    ```bash
    grep "pub mod storage" src/lib.rs
    grep "Database" src/error.rs
    ```
  </verify>
  <done>
    `src/lib.rs` includes `pub mod storage;`. `Error` enum has a `Database(sqlx::Error)` variant with `#[from]` for auto-conversion, and the `IntoResponse` match arm handles it as `INTERNAL_SERVER_ERROR`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SqlitePool to AppState and initialize in run_server</name>
  <files>src/proxy/server.rs</files>
  <action>
    1. In `src/proxy/server.rs`, update `AppState` to include the database pool:

       Add import:
       ```rust
       use sqlx::SqlitePool;
       ```

       Update the struct:
       ```rust
       #[derive(Clone)]
       pub struct AppState {
           pub router: Arc<ProviderRouter>,
           pub http_client: Client,
           pub config: Arc<Config>,
           pub db: Option<SqlitePool>,
       }
       ```

    2. In `run_server()`, initialize the pool before creating AppState:

       After the `http_client` creation and before constructing `state`, add:
       ```rust
       // Initialize database pool if configured
       let db = {
           let db_config = config.database();
           match crate::storage::init_pool(&db_config.path).await {
               Ok(pool) => {
                   tracing::info!(path = %db_config.path, "Database initialized");
                   Some(pool)
               }
               Err(e) => {
                   tracing::warn!(error = %e, "Failed to initialize database, logging disabled");
                   None
               }
           }
       };
       ```

       Then include `db` in the `AppState` construction:
       ```rust
       let state = AppState {
           router: Arc::new(provider_router),
           http_client,
           config: Arc::new(config),
           db,
       };
       ```

       Note: Database initialization failure is a warning, not fatal. The proxy runs without logging if the database can't be created. This matches the `Option<SqlitePool>` design.
  </action>
  <verify>
    ```bash
    # Compile to verify everything works together
    cargo build 2>&1 | tail -10

    # Verify AppState has db field
    grep "db:" src/proxy/server.rs

    # Verify pool initialization in run_server
    grep "init_pool" src/proxy/server.rs

    # All tests pass
    cargo test

    # No clippy warnings
    cargo clippy -- -D warnings
    ```
  </verify>
  <done>
    - `AppState` has `db: Option<SqlitePool>` field
    - `run_server()` initializes the pool using `storage::init_pool()` and logs success/failure
    - `cargo build` succeeds
    - `cargo test` passes all existing tests
    - `cargo clippy` produces no warnings
  </done>
</task>

</tasks>

<verification>
```bash
# Full build succeeds
cargo build 2>&1 | tail -10

# All existing tests pass (no regressions)
cargo test

# No clippy warnings
cargo clippy -- -D warnings

# Storage module registered
grep "pub mod storage" src/lib.rs

# Error has Database variant
grep "Database" src/error.rs

# AppState has db field
grep "db:" src/proxy/server.rs

# Pool initialized in run_server
grep "init_pool" src/proxy/server.rs
```
</verification>

<success_criteria>
- `cargo build` succeeds with no errors
- `cargo test` passes all existing tests (no regressions)
- `cargo clippy -- -D warnings` produces no warnings
- `src/lib.rs` includes `pub mod storage;`
- `Error::Database` variant exists for pool initialization errors
- `AppState` has `db: Option<SqlitePool>`
- `run_server` initializes the pool on startup (non-fatal on failure)
</success_criteria>

<output>
After completion, create `.planning/phases/02-request-logging/02-02-SUMMARY.md`
</output>
