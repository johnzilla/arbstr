---
phase: 02-request-logging
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/proxy/server.rs
  - src/proxy/mod.rs
autonomous: true

must_haves:
  truths:
    - "Each request gets a unique UUID stored in both the tracing span and request extensions"
    - "Handlers can extract the correlation ID via Extension<RequestId>"
    - "The tracing span and request extensions contain the SAME UUID value"
    - "Existing server functionality is unchanged (endpoints, middleware ordering, test results)"
  artifacts:
    - path: "src/proxy/server.rs"
      provides: "RequestId newtype, middleware layer, updated TraceLayer make_span_with"
      contains: "RequestId"
    - path: "src/proxy/handlers.rs"
      provides: "Handler signature updated to accept Extension<RequestId> (ready for use in 02-04)"
      contains: "RequestId"
  key_links:
    - from: "axum::middleware::from_fn"
      to: "RequestId"
      via: "Middleware inserts RequestId into request extensions"
      pattern: "extensions_mut.*insert.*RequestId"
    - from: "make_span_with"
      to: "RequestId"
      via: "Reads UUID from extensions instead of generating"
      pattern: "get::<RequestId>"
---

<objective>
Make the correlation UUID accessible to handlers via request extensions, while keeping it in the tracing span.

Purpose: Phase 1 put the UUID only in the tracing span, but tracing deliberately does not expose span field values programmatically. For Phase 2 logging, handlers need the correlation ID as a String to INSERT into SQLite. This plan generates the UUID in a middleware that stores it in request extensions, then modifies make_span_with to read from extensions rather than generating its own UUID.

Output: RequestId available in handlers via Extension extractor. Same UUID in both span and extension.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-request-logging/02-CONTEXT.md
@.planning/phases/02-request-logging/02-RESEARCH.md
@src/proxy/server.rs
@src/proxy/handlers.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RequestId newtype and middleware to server.rs</name>
  <files>src/proxy/server.rs</files>
  <action>
    Modify `src/proxy/server.rs` to:

    1. Add a `RequestId` newtype at module level (before `AppState`):

       ```rust
       /// Per-request correlation ID stored in request extensions.
       ///
       /// Generated by middleware and accessible to handlers via `Extension<RequestId>`.
       /// The same UUID is also recorded in the tracing span for structured log output.
       #[derive(Clone, Debug)]
       pub struct RequestId(pub Uuid);
       ```

    2. Add a middleware function that generates the UUID and stores it in extensions. Add this as a standalone async function (not a closure) after the `create_router` function:

       ```rust
       /// Middleware that generates a correlation ID and stores it in request extensions.
       async fn inject_request_id(
           mut request: axum::http::Request<axum::body::Body>,
           next: axum::middleware::Next,
       ) -> Response {
           let request_id = Uuid::new_v4();
           request.extensions_mut().insert(RequestId(request_id));
           next.run(request).await
       }
       ```

       Add the necessary import:
       ```rust
       use axum::response::Response;
       use axum::middleware;
       ```

    3. Update `create_router` to add the middleware layer BEFORE TraceLayer (so extensions are populated when make_span_with runs). Layer ordering in axum is last-added = outermost. We need `inject_request_id` to run first (outermost), then TraceLayer. So the middleware layer must be added AFTER TraceLayer in the builder chain:

       ```rust
       pub fn create_router(state: AppState) -> Router {
           Router::new()
               .route("/v1/chat/completions", post(handlers::chat_completions))
               .route("/v1/models", get(handlers::list_models))
               .route("/health", get(handlers::health))
               .route("/providers", get(handlers::list_providers))
               .with_state(state)
               .layer(
                   TraceLayer::new_for_http().make_span_with(
                       |request: &axum::http::Request<axum::body::Body>| {
                           let request_id = request
                               .extensions()
                               .get::<RequestId>()
                               .map(|r| r.0)
                               .unwrap_or_else(Uuid::new_v4);
                           tracing::info_span!(
                               "request",
                               method = %request.method(),
                               uri = %request.uri(),
                               request_id = %request_id,
                           )
                       },
                   ),
               )
               .layer(middleware::from_fn(inject_request_id))
       }
       ```

       IMPORTANT: `.layer(middleware::from_fn(inject_request_id))` must be the LAST `.layer()` call because axum applies layers in reverse order (last layer = outermost = runs first). This means inject_request_id runs first, populates extensions, then TraceLayer's make_span_with can read the UUID from extensions.
  </action>
  <verify>
    ```bash
    # Compiles cleanly
    cargo build 2>&1 | tail -5

    # All existing tests still pass
    cargo test

    # No clippy warnings
    cargo clippy -- -D warnings

    # Verify RequestId struct exists
    grep "pub struct RequestId" src/proxy/server.rs

    # Verify middleware function exists
    grep "async fn inject_request_id" src/proxy/server.rs

    # Verify extensions().get::<RequestId>() in make_span_with
    grep "get::<RequestId>" src/proxy/server.rs

    # Verify middleware layer is added
    grep "from_fn(inject_request_id)" src/proxy/server.rs
    ```
  </verify>
  <done>
    - `RequestId` newtype exists wrapping `Uuid`
    - `inject_request_id` middleware generates UUID and stores in extensions
    - `make_span_with` reads UUID from extensions (with fallback to new UUID)
    - Middleware layer is outermost (last `.layer()` call)
    - `cargo build` succeeds
    - `cargo test` passes all existing tests
    - `cargo clippy` clean
  </done>
</task>

<task type="auto">
  <name>Task 2: Export RequestId from proxy module</name>
  <files>src/proxy/mod.rs</files>
  <action>
    Update `src/proxy/mod.rs` to re-export `RequestId` so handlers and future modules can use it:

    Change:
    ```rust
    pub use server::{run_server, AppState};
    ```

    To:
    ```rust
    pub use server::{run_server, AppState, RequestId};
    ```
  </action>
  <verify>
    ```bash
    grep "RequestId" src/proxy/mod.rs
    ```
  </verify>
  <done>
    `RequestId` is re-exported from `src/proxy/mod.rs`.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify handlers can access RequestId (preparation for 02-04)</name>
  <files>src/proxy/handlers.rs</files>
  <action>
    This task verifies that the RequestId extension is accessible in handlers but does NOT yet add logging logic (that's 02-04).

    No code changes to handlers.rs in this task. Just verify that the build succeeds and the RequestId type is importable.

    Run:
    ```bash
    cargo build
    cargo test
    cargo clippy -- -D warnings
    ```

    The handlers will use `Extension<RequestId>` in plan 02-04 when logging is integrated.
  </action>
  <verify>
    ```bash
    # Full build succeeds
    cargo build 2>&1 | tail -5

    # All tests pass
    cargo test

    # No warnings
    cargo clippy -- -D warnings
    ```
  </verify>
  <done>
    Build succeeds, all tests pass, clippy clean. RequestId is available for handler use in 02-04.
  </done>
</task>

</tasks>

<verification>
```bash
# Full build succeeds
cargo build 2>&1 | tail -5

# All existing tests pass
cargo test

# No clippy warnings
cargo clippy -- -D warnings

# RequestId newtype exists
grep "pub struct RequestId" src/proxy/server.rs

# Middleware generates UUID and stores in extensions
grep "extensions_mut.*insert.*RequestId" src/proxy/server.rs

# make_span_with reads from extensions
grep "get::<RequestId>" src/proxy/server.rs

# RequestId re-exported
grep "RequestId" src/proxy/mod.rs
```
</verification>

<success_criteria>
- `RequestId(Uuid)` newtype is defined and exported from proxy module
- `inject_request_id` middleware stores UUID in request extensions
- `make_span_with` reads UUID from extensions (same UUID in span and extensions)
- Middleware runs before TraceLayer (outermost layer)
- `cargo build` succeeds, `cargo test` passes, `cargo clippy` clean
- No changes to handler logic (that's 02-04)
</success_criteria>

<output>
After completion, create `.planning/phases/02-request-logging/02-03-SUMMARY.md`
</output>
