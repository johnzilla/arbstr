---
phase: 09-sse-stream-interception
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/proxy/stream.rs
  - src/proxy/mod.rs
autonomous: true

must_haves:
  truths:
    - "wrap_sse_stream returns a stream that passes all bytes through unmodified and a handle to read the StreamResult"
    - "Panics in extraction logic are caught and do not affect the byte passthrough"
    - "When the stream is fully consumed, the StreamResult is available in the handle"
    - "When the stream is dropped before completion, the handle still receives a result (via Drop)"
    - "The stream module is registered in proxy/mod.rs and exports public types"
  artifacts:
    - path: "src/proxy/stream.rs"
      provides: "wrap_sse_stream public function, StreamResultHandle type, Drop-based finalization"
      exports: ["wrap_sse_stream", "StreamResult", "StreamUsage", "StreamResultHandle"]
    - path: "src/proxy/mod.rs"
      provides: "pub mod stream declaration and re-exports"
      contains: "pub mod stream"
  key_links:
    - from: "src/proxy/stream.rs::wrap_sse_stream"
      to: "src/proxy/stream.rs::SseObserver"
      via: "Arc<Mutex<SseObserver>> captured in .map() closure"
      pattern: "Arc::new.*Mutex::new.*SseObserver"
    - from: "src/proxy/stream.rs::SseObserver::Drop"
      to: "StreamResultHandle"
      via: "Drop impl writes result to shared handle"
      pattern: "impl Drop for SseObserver"
---

<objective>
Add the wrap_sse_stream public API with panic isolation, Drop-based finalization, and module registration.

Purpose: This completes Phase 9 by providing the public interface that Phase 10 will call to wrap upstream byte streams. The wrap function is thin glue around SseObserver (built in Plan 1) with two critical additions: panic isolation via catch_unwind and Drop-based result delivery.

Output: Complete `src/proxy/stream.rs` module with public API, registered in `src/proxy/mod.rs`, all tests passing.
</objective>

<execution_context>
@/home/john/.claude/get-shit-done/workflows/execute-plan.md
@/home/john/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-sse-stream-interception/09-RESEARCH.md
@.planning/phases/09-sse-stream-interception/09-01-SUMMARY.md
@src/proxy/stream.rs (from Plan 1)
@src/proxy/mod.rs
@src/proxy/handlers.rs (lines 670-716 for existing stream pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add wrap_sse_stream with panic isolation and Drop finalization</name>
  <files>src/proxy/stream.rs, src/proxy/mod.rs</files>
  <action>
    In src/proxy/stream.rs, add the public stream wrapping API:

    1. **StreamResultHandle type alias**: `pub type StreamResultHandle = Arc<Mutex<Option<StreamResult>>>;`

    2. **Modify SseObserver** to hold an `Option<StreamResultHandle>` field called `result_handle`. Update SseObserver::new to accept a StreamResultHandle parameter and store it as Some(...).

    3. **Add Drop impl for SseObserver**: In Drop::drop, call self.flush_buffer() to handle any remaining buffer content (e.g., [DONE] without trailing newline). Build the StreamResult (empty if !done_received, full otherwise). Write it to self.result_handle using take() + lock(). Use unwrap_or_else on the lock to recover from poisoned mutexes (per research recommendation: `lock().unwrap_or_else(|e| e.into_inner())`).

    4. **Adjust SseObserver::into_result**: Keep this method for direct unit testing (Plan 1 tests use it). It should still call flush_buffer and return the result. When into_result is called, take the result_handle (set to None) so Drop does not double-write.

    5. **Add wrap_sse_stream function** (pub):
       ```
       pub fn wrap_sse_stream<S>(stream: S) -> (impl Stream<Item = Result<Bytes, std::io::Error>>, StreamResultHandle)
       where
           S: Stream<Item = Result<Bytes, reqwest::Error>>,
       ```
       - Create a StreamResultHandle (Arc<Mutex<None>>)
       - Create an SseObserver with the handle clone
       - Wrap observer in Arc<Mutex<_>> for the closure
       - Use stream.map(move |chunk_result| { ... }) pattern:
         - On Ok(bytes): wrap observer.lock().process_chunk(&bytes) in std::panic::catch_unwind(AssertUnwindSafe(|| ...)). On panic, log at error level. Use unwrap_or_else on lock for poisoned mutex recovery.
         - On Err(e): log error
         - Convert reqwest::Error to std::io::Error via std::io::Error::other
       - Return (wrapped_stream, handle)

    6. **Register module in src/proxy/mod.rs**:
       - Add `pub mod stream;` declaration
       - Add re-exports: `pub use stream::{wrap_sse_stream, StreamResult, StreamUsage, StreamResultHandle};`

    7. **Add tests** in the existing #[cfg(test)] module in stream.rs:
       - test_wrap_sse_stream_basic: Create a mock stream from Vec<Result<Bytes, reqwest::Error>>, wrap it, consume all items, verify bytes pass through unmodified, verify StreamResult is available in handle with correct values.
       - test_wrap_sse_stream_no_done: Mock stream without [DONE], verify handle contains empty result after consumption.
       - test_wrap_panic_isolation: Create an observer test that would panic (e.g., by feeding carefully crafted input after poisoning the mutex), verify the stream continues yielding bytes. (Note: this is tricky to test directly -- at minimum verify that catch_unwind is in the code path by testing that a stream with valid bytes still works even if wrapped.)
       - test_drop_writes_result: Create a wrapped stream, drop it without consuming all items, verify the handle still contains a result (via Drop).

    For the mock stream in tests, use `futures::stream::iter(vec![Ok(Bytes::from("data: ...")), ...])`.
  </action>
  <verify>
    ```bash
    cargo test --lib proxy::stream -- --nocapture
    cargo clippy -- -D warnings
    cargo build
    ```
    All Plan 1 tests still pass. New tests pass. No warnings. Module compiles and exports are accessible.
  </verify>
  <done>
    wrap_sse_stream accepts a byte stream and returns (wrapped_stream, StreamResultHandle). Panics in extraction are caught. Drop on SseObserver writes the result to the handle. Module is registered in proxy/mod.rs with public exports. All tests pass including both Plan 1 and Plan 2 tests.
  </done>
</task>

</tasks>

<verification>
```bash
# All stream module tests pass
cargo test --lib proxy::stream -- --nocapture

# Full test suite passes (no regression)
cargo test

# No warnings
cargo clippy -- -D warnings

# Verify public exports compile
cargo build
```

Verify the module is properly registered:
```bash
grep "pub mod stream" src/proxy/mod.rs
grep "wrap_sse_stream" src/proxy/mod.rs
```
</verification>

<success_criteria>
- wrap_sse_stream compiles and returns the correct types
- Panic isolation is implemented via catch_unwind in the .map() closure
- Drop impl on SseObserver writes result to handle on stream drop
- All Plan 1 unit tests still pass (no regression)
- New integration-style tests verify the full wrap_sse_stream flow
- Module registered in proxy/mod.rs with public exports
- cargo test (full suite) passes
- cargo clippy clean
</success_criteria>

<output>
After completion, create `.planning/phases/09-sse-stream-interception/09-02-SUMMARY.md`
</output>
